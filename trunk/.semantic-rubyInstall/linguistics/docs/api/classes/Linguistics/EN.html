<?xml version="1.0" encoding="iso-8859-1"?>
<!DOCTYPE html 
     PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
     "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
  <title>Module: Linguistics::EN</title>
  <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1" />
  <meta http-equiv="Content-Script-Type" content="text/javascript" />
  <link rel="stylesheet" href="../.././rdoc-style.css" type="text/css" media="screen" />
  <script type="text/javascript">
  // <![CDATA[

  function popupCode( url ) {
    window.open(url, "Code", "resizable=yes,scrollbars=yes,toolbar=no,status=no,height=150,width=400")
  }

  function toggleCode( id ) {
    if ( document.getElementById )
      elem = document.getElementById( id );
    else if ( document.all )
      elem = eval( "document.all." + id );
    else
      return false;

    elemStyle = elem.style;
    
    if ( elemStyle.display != "block" ) {
      elemStyle.display = "block"
    } else {
      elemStyle.display = "none"
    }

    return true;
  }
  
  // Make codeblocks hidden by default
  document.writeln( "<style type=\"text/css\">div.method-source-code { display: none }</style>" )
  
  // ]]>
  </script>

</head>
<body>



    <div id="classHeader">
        <table class="header-table">
        <tr class="top-aligned-row">
          <td><strong>Module</strong></td>
          <td class="class-name-in-header">Linguistics::EN</td>
        </tr>
        <tr class="top-aligned-row">
            <td><strong>In:</strong></td>
            <td>
                <a href="../../files/lib/linguistics/en/linkparser_rb.html">
                lib/linguistics/en/linkparser.rb
                </a>
        &nbsp;(<a href="http://deveiate.org/projects/Linguistics/browser/trunk/lib/linguistics/en/linkparser.rb"><acronym title="Concurrent Versioning System">CVS</acronym></a>)
        <br />
                <a href="../../files/lib/linguistics/en/infinitive_rb.html">
                lib/linguistics/en/infinitive.rb
                </a>
        &nbsp;(<a href="http://deveiate.org/projects/Linguistics/browser/trunk/lib/linguistics/en/infinitive.rb"><acronym title="Concurrent Versioning System">CVS</acronym></a>)
        <br />
                <a href="../../files/lib/linguistics/en/wordnet_rb.html">
                lib/linguistics/en/wordnet.rb
                </a>
        &nbsp;(<a href="http://deveiate.org/projects/Linguistics/browser/trunk/lib/linguistics/en/wordnet.rb"><acronym title="Concurrent Versioning System">CVS</acronym></a>)
        <br />
                <a href="../../files/lib/linguistics/en_rb.html">
                lib/linguistics/en.rb
                </a>
        &nbsp;(<a href="http://deveiate.org/projects/Linguistics/browser/trunk/lib/linguistics/en.rb"><acronym title="Concurrent Versioning System">CVS</acronym></a>)
        <br />
            </td>
        </tr>

        </table>
    </div>
  <!-- banner header -->

  <div id="bodyContent">



  <div id="contextContent">

    <div id="description">
      <p>
This module contains English-<a href="EN.html#M000041">language</a>
linguistics functions accessible from the <a
href="../Linguistics.html">Linguistics</a> module, or as <a
href="EN.html#M000047">a</a> standalone function library.
</p>

    </div>


   </div>

    <div id="method-list">
      <h3 class="section-bar">Methods</h3>

      <div class="name-list">
      <a href="#M000047">a</a>&nbsp;&nbsp;
      <a href="#M000048">an</a>&nbsp;&nbsp;
      <a href="#M000057">camel_case_to_english</a>&nbsp;&nbsp;
      <a href="#M000056">conjunction</a>&nbsp;&nbsp;
      <a href="#M000028">def_lprintf_formatter</a>&nbsp;&nbsp;
      <a href="#M000024">def_synset_function</a>&nbsp;&nbsp;
      <a href="#M000058">english_to_camel_case</a>&nbsp;&nbsp;
      <a href="#M000016">has_link_parser?</a>&nbsp;&nbsp;
      <a href="#M000021">has_wordnet?</a>&nbsp;&nbsp;
      <a href="#M000035">indef_article</a>&nbsp;&nbsp;
      <a href="#M000020">infinitive</a>&nbsp;&nbsp;
      <a href="#M000041">language</a>&nbsp;&nbsp;
      <a href="#M000018">lp_dict</a>&nbsp;&nbsp;
      <a href="#M000017">lp_error</a>&nbsp;&nbsp;
      <a href="#M000060">lprintf</a>&nbsp;&nbsp;
      <a href="#M000027">matchgroup</a>&nbsp;&nbsp;
      <a href="#M000049">no</a>&nbsp;&nbsp;
      <a href="#M000029">normalize_count</a>&nbsp;&nbsp;
      <a href="#M000040">number_to_words</a>&nbsp;&nbsp;
      <a href="#M000052">numwords</a>&nbsp;&nbsp;
      <a href="#M000053">ordinal</a>&nbsp;&nbsp;
      <a href="#M000054">ordinate</a>&nbsp;&nbsp;
      <a href="#M000051">part_pres</a>&nbsp;&nbsp;
      <a href="#M000042">plural</a>&nbsp;&nbsp;
      <a href="#M000046">plural_adj</a>&nbsp;&nbsp;
      <a href="#M000045">plural_adjective</a>&nbsp;&nbsp;
      <a href="#M000043">plural_noun</a>&nbsp;&nbsp;
      <a href="#M000044">plural_verb</a>&nbsp;&nbsp;
      <a href="#M000033">pluralize_general_verb</a>&nbsp;&nbsp;
      <a href="#M000031">pluralize_noun</a>&nbsp;&nbsp;
      <a href="#M000034">pluralize_special_adjective</a>&nbsp;&nbsp;
      <a href="#M000032">pluralize_special_verb</a>&nbsp;&nbsp;
      <a href="#M000030">postprocess</a>&nbsp;&nbsp;
      <a href="#M000050">present_participle</a>&nbsp;&nbsp;
      <a href="#M000059">proper_noun</a>&nbsp;&nbsp;
      <a href="#M000055">quantify</a>&nbsp;&nbsp;
      <a href="#M000019">sentence</a>&nbsp;&nbsp;
      <a href="#M000025">synset</a>&nbsp;&nbsp;
      <a href="#M000026">synsets</a>&nbsp;&nbsp;
      <a href="#M000038">to_hundreds</a>&nbsp;&nbsp;
      <a href="#M000037">to_tens</a>&nbsp;&nbsp;
      <a href="#M000039">to_thousands</a>&nbsp;&nbsp;
      <a href="#M000036">to_units</a>&nbsp;&nbsp;
      <a href="#M000022">wn_error</a>&nbsp;&nbsp;
      <a href="#M000023">wn_lexicon</a>&nbsp;&nbsp;
      </div>
    </div>

  </div>


    <!-- if includes -->
    <div id="includes">
      <h3 class="section-bar">Included Modules</h3>

      <div id="includes-list">
        <span class="include-name">CrossCase</span>
      </div>
    </div>

    <div id="section">

    <div id="class-list">
      <h3 class="section-bar">Classes and Modules</h3>

      Class <a href="EN/Infinitive.html" class="link">Linguistics::EN::Infinitive</a><br />

    </div>

    <div id="constants-list">
      <h3 class="section-bar">Constants</h3>

      <div class="name-list">
        <table summary="Constants">
        <tr class="top-aligned-row context-row">
          <td class="context-item-name">SVNRev</td>
          <td>=</td>
          <td class="context-item-value">%q$Rev: 99 $</td>
          <td width="3em">&nbsp;</td>
          <td class="context-item-desc">
Subversion revision

</td>
        </tr>
        <tr class="top-aligned-row context-row">
          <td class="context-item-name">SVNId</td>
          <td>=</td>
          <td class="context-item-value">%q$Id: en.rb 99 2008-09-06 05:20:07Z deveiant $</td>
          <td width="3em">&nbsp;</td>
          <td class="context-item-desc">
Subversion revision tag

</td>
        </tr>
        </table>
      </div>
    </div>



    <div id="attribute-list">
      <h3 class="section-bar">Attributes</h3>

      <div class="name-list">
        <table>
        <tr class="top-aligned-row context-row">
          <td class="context-item-name">lprintf_formatters</td>
          <td class="context-item-value">&nbsp;[RW]&nbsp;</td>
          <td class="context-item-desc"></td>
        </tr>
        </table>
      </div>
    </div>
      


    <!-- if method_list -->
    <div id="methods">
      <h3 class="section-bar">Public Class methods</h3>

      <div id="method-M000028" class="method-detail">
        <a name="M000028"></a>

        <div class="method-heading">
          <a href="#M000028" class="method-signature">
          <span class="method-name">def_lprintf_formatter</span><span class="method-args">( name, meth )</span>
          </a>
        </div>
      
        <div class="method-description">
          <p>
Add the specified method (which can be either <a
href="EN.html#M000047">a</a> Method object or <a
href="EN.html#M000047">a</a> Symbol for looking up <a
href="EN.html#M000047">a</a> method)
</p>
          <p><a class="source-toggle" href="#"
            onclick="toggleCode('M000028-source');return false;">[Source]</a></p>
          <div class="method-source-code" id="M000028-source">
<pre>
     <span class="ruby-comment cmt"># File lib/linguistics/en.rb, line 130</span>
130:     <span class="ruby-keyword kw">def</span> <span class="ruby-keyword kw">self</span><span class="ruby-operator">::</span><span class="ruby-identifier">def_lprintf_formatter</span>( <span class="ruby-identifier">name</span>, <span class="ruby-identifier">meth</span> )
131:         <span class="ruby-identifier">meth</span> = <span class="ruby-keyword kw">self</span>.<span class="ruby-identifier">method</span>( <span class="ruby-identifier">meth</span> ) <span class="ruby-keyword kw">unless</span> <span class="ruby-identifier">meth</span>.<span class="ruby-identifier">is_a?</span>( <span class="ruby-constant">Method</span> )
132:         <span class="ruby-keyword kw">self</span>.<span class="ruby-identifier">lprintf_formatters</span>[ <span class="ruby-identifier">name</span> ] = <span class="ruby-identifier">meth</span>
133:     <span class="ruby-keyword kw">end</span>
</pre>
          </div>
        </div>
      </div>

      <div id="method-M000024" class="method-detail">
        <a name="M000024"></a>

        <div class="method-heading">
          <a href="#M000024" class="method-signature">
          <span class="method-name">def_synset_function</span><span class="method-args">( meth )</span>
          </a>
        </div>
      
        <div class="method-description">
          <p>
Make <a href="EN.html#M000047">a</a> function that calls the method
<tt>meth</tt> on the <a href="EN.html#M000025">synset</a> of <a
href="EN.html#M000048">an</a> input word.
</p>
          <p><a class="source-toggle" href="#"
            onclick="toggleCode('M000024-source');return false;">[Source]</a></p>
          <div class="method-source-code" id="M000024-source">
<pre>
     <span class="ruby-comment cmt"># File lib/linguistics/en/wordnet.rb, line 123</span>
123:         <span class="ruby-keyword kw">def</span> <span class="ruby-identifier">def_synset_function</span>( <span class="ruby-identifier">meth</span> )
124:             (<span class="ruby-keyword kw">class</span> <span class="ruby-operator">&lt;&lt;</span> <span class="ruby-keyword kw">self</span>; <span class="ruby-keyword kw">self</span>; <span class="ruby-keyword kw">end</span>).<span class="ruby-identifier">instance_eval</span> <span class="ruby-keyword kw">do</span>
125:                 <span class="ruby-identifier">define_method</span>( <span class="ruby-identifier">meth</span> ) {<span class="ruby-operator">|</span><span class="ruby-operator">*</span><span class="ruby-identifier">args</span><span class="ruby-operator">|</span>
126:                     <span class="ruby-identifier">word</span>, <span class="ruby-identifier">pos</span>, <span class="ruby-identifier">sense</span> = <span class="ruby-operator">*</span><span class="ruby-identifier">args</span>
127:                     <span class="ruby-identifier">raise</span> <span class="ruby-constant">ArgumentError</span>,
128:                         <span class="ruby-value str">&quot;wrong number of arguments (0 for 1)&quot;</span> <span class="ruby-keyword kw">unless</span> <span class="ruby-identifier">word</span>
129:                     <span class="ruby-identifier">sense</span> <span class="ruby-operator">||=</span> <span class="ruby-value">1</span>
130: 
131:                     <span class="ruby-identifier">syn</span> = <span class="ruby-identifier">synset</span>( <span class="ruby-identifier">word</span>.<span class="ruby-identifier">to_s</span>, <span class="ruby-identifier">pos</span>, <span class="ruby-identifier">sense</span> )
132:                     <span class="ruby-keyword kw">return</span> <span class="ruby-identifier">syn</span>.<span class="ruby-identifier">nil?</span> <span class="ruby-value">? </span><span class="ruby-keyword kw">nil</span> <span class="ruby-operator">:</span> <span class="ruby-identifier">syn</span>.<span class="ruby-identifier">send</span>( <span class="ruby-identifier">meth</span> )
133:                 }
134:             <span class="ruby-keyword kw">end</span>
135:         <span class="ruby-keyword kw">end</span>
</pre>
          </div>
        </div>
      </div>

      <div id="method-M000016" class="method-detail">
        <a name="M000016"></a>

        <div class="method-heading">
          <a href="#M000016" class="method-signature">
          <span class="method-name">has_link_parser?</span><span class="method-args">()</span>
          </a>
        </div>
      
        <div class="method-description">
          <p>
Returns <tt>true</tt> if LinkParser was loaded okay
</p>
          <p><a class="source-toggle" href="#"
            onclick="toggleCode('M000016-source');return false;">[Source]</a></p>
          <div class="method-source-code" id="M000016-source">
<pre>
    <span class="ruby-comment cmt"># File lib/linguistics/en/linkparser.rb, line 81</span>
81:         <span class="ruby-keyword kw">def</span> <span class="ruby-identifier">has_link_parser?</span> ; <span class="ruby-ivar">@has_link_parser</span> ; <span class="ruby-keyword kw">end</span>
</pre>
          </div>
        </div>
      </div>

      <div id="method-M000021" class="method-detail">
        <a name="M000021"></a>

        <div class="method-heading">
          <a href="#M000021" class="method-signature">
          <span class="method-name">has_wordnet?</span><span class="method-args">()</span>
          </a>
        </div>
      
        <div class="method-description">
          <p>
Returns <tt>true</tt> if WordNet was loaded okay
</p>
          <p><a class="source-toggle" href="#"
            onclick="toggleCode('M000021-source');return false;">[Source]</a></p>
          <div class="method-source-code" id="M000021-source">
<pre>
     <span class="ruby-comment cmt"># File lib/linguistics/en/wordnet.rb, line 103</span>
103:         <span class="ruby-keyword kw">def</span> <span class="ruby-identifier">has_wordnet?</span> ; <span class="ruby-ivar">@has_wordnet</span>; <span class="ruby-keyword kw">end</span>
</pre>
          </div>
        </div>
      </div>

      <div id="method-M000018" class="method-detail">
        <a name="M000018"></a>

        <div class="method-heading">
          <a href="#M000018" class="method-signature">
          <span class="method-name">lp_dict</span><span class="method-args">()</span>
          </a>
        </div>
      
        <div class="method-description">
          <p>
The instance of LinkParser used for all <a
href="../Linguistics.html">Linguistics</a> LinkParser functions.
</p>
          <p><a class="source-toggle" href="#"
            onclick="toggleCode('M000018-source');return false;">[Source]</a></p>
          <div class="method-source-code" id="M000018-source">
<pre>
    <span class="ruby-comment cmt"># File lib/linguistics/en/linkparser.rb, line 89</span>
89:         <span class="ruby-keyword kw">def</span> <span class="ruby-identifier">lp_dict</span>
90:             <span class="ruby-keyword kw">if</span> <span class="ruby-ivar">@lp_error</span>
91:                 <span class="ruby-identifier">raise</span> <span class="ruby-constant">NotImplementedError</span>, 
92:                     <span class="ruby-value str">&quot;LinkParser functions are not loaded: %s&quot;</span> <span class="ruby-operator">%</span>
93:                     <span class="ruby-ivar">@lp_error</span>.<span class="ruby-identifier">message</span>
94:             <span class="ruby-keyword kw">end</span>
95: 
96:             <span class="ruby-keyword kw">return</span> <span class="ruby-ivar">@lp_dict</span> <span class="ruby-operator">||=</span> <span class="ruby-constant">LinkParser</span><span class="ruby-operator">::</span><span class="ruby-constant">Dictionary</span>.<span class="ruby-identifier">new</span>( <span class="ruby-identifier">:verbosity</span> =<span class="ruby-operator">&gt;</span> <span class="ruby-value">0</span> )
97:         <span class="ruby-keyword kw">end</span>
</pre>
          </div>
        </div>
      </div>

      <div id="method-M000017" class="method-detail">
        <a name="M000017"></a>

        <div class="method-heading">
          <a href="#M000017" class="method-signature">
          <span class="method-name">lp_error</span><span class="method-args">()</span>
          </a>
        </div>
      
        <div class="method-description">
          <p>
If #has_link_parser? returns <tt>false</tt>, this can be called to fetch
the exception which was raised when trying to load LinkParser.
</p>
          <p><a class="source-toggle" href="#"
            onclick="toggleCode('M000017-source');return false;">[Source]</a></p>
          <div class="method-source-code" id="M000017-source">
<pre>
    <span class="ruby-comment cmt"># File lib/linguistics/en/linkparser.rb, line 85</span>
85:         <span class="ruby-keyword kw">def</span> <span class="ruby-identifier">lp_error</span> ; <span class="ruby-ivar">@lp_error</span> ; <span class="ruby-keyword kw">end</span>
</pre>
          </div>
        </div>
      </div>

      <div id="method-M000027" class="method-detail">
        <a name="M000027"></a>

        <div class="method-heading">
          <a href="#M000027" class="method-signature">
          <span class="method-name">matchgroup</span><span class="method-args">( *parts )</span>
          </a>
        </div>
      
        <div class="method-description">
          <p>
Wrap one or more parts in <a href="EN.html#M000047">a</a> non-capturing
alteration Regexp
</p>
          <p><a class="source-toggle" href="#"
            onclick="toggleCode('M000027-source');return false;">[Source]</a></p>
          <div class="method-source-code" id="M000027-source">
<pre>
     <span class="ruby-comment cmt"># File lib/linguistics/en.rb, line 117</span>
117:     <span class="ruby-keyword kw">def</span> <span class="ruby-keyword kw">self</span><span class="ruby-operator">::</span><span class="ruby-identifier">matchgroup</span>( <span class="ruby-operator">*</span><span class="ruby-identifier">parts</span> )
118:         <span class="ruby-identifier">re</span> = <span class="ruby-identifier">parts</span>.<span class="ruby-identifier">flatten</span>.<span class="ruby-identifier">join</span>(<span class="ruby-value str">&quot;|&quot;</span>)
119:         <span class="ruby-node">&quot;(?:#{re})&quot;</span>
120:     <span class="ruby-keyword kw">end</span>
</pre>
          </div>
        </div>
      </div>

      <div id="method-M000022" class="method-detail">
        <a name="M000022"></a>

        <div class="method-heading">
          <a href="#M000022" class="method-signature">
          <span class="method-name">wn_error</span><span class="method-args">()</span>
          </a>
        </div>
      
        <div class="method-description">
          <p>
If #haveWordnet? returns <tt>false</tt>, this can be called to fetch the
exception which was raised when WordNet was loaded.
</p>
          <p><a class="source-toggle" href="#"
            onclick="toggleCode('M000022-source');return false;">[Source]</a></p>
          <div class="method-source-code" id="M000022-source">
<pre>
     <span class="ruby-comment cmt"># File lib/linguistics/en/wordnet.rb, line 107</span>
107:         <span class="ruby-keyword kw">def</span> <span class="ruby-identifier">wn_error</span> ; <span class="ruby-ivar">@wn_error</span>; <span class="ruby-keyword kw">end</span>
</pre>
          </div>
        </div>
      </div>

      <div id="method-M000023" class="method-detail">
        <a name="M000023"></a>

        <div class="method-heading">
          <a href="#M000023" class="method-signature">
          <span class="method-name">wn_lexicon</span><span class="method-args">()</span>
          </a>
        </div>
      
        <div class="method-description">
          <p>
The instance of the WordNet::Lexicon used for all <a
href="../Linguistics.html">Linguistics</a> WordNet functions.
</p>
          <p><a class="source-toggle" href="#"
            onclick="toggleCode('M000023-source');return false;">[Source]</a></p>
          <div class="method-source-code" id="M000023-source">
<pre>
     <span class="ruby-comment cmt"># File lib/linguistics/en/wordnet.rb, line 111</span>
111:         <span class="ruby-keyword kw">def</span> <span class="ruby-identifier">wn_lexicon</span>
112:             <span class="ruby-keyword kw">if</span> <span class="ruby-ivar">@wn_error</span>
113:                 <span class="ruby-identifier">raise</span> <span class="ruby-constant">NotImplementedError</span>,
114:                     <span class="ruby-value str">&quot;WordNet functions are not loaded: %s&quot;</span> <span class="ruby-operator">%</span>
115:                     <span class="ruby-ivar">@wn_error</span>.<span class="ruby-identifier">message</span>
116:             <span class="ruby-keyword kw">end</span>
117: 
118:             <span class="ruby-ivar">@wn_lexicon</span> <span class="ruby-operator">||=</span> <span class="ruby-constant">WordNet</span><span class="ruby-operator">::</span><span class="ruby-constant">Lexicon</span><span class="ruby-operator">::</span><span class="ruby-identifier">new</span>
119:         <span class="ruby-keyword kw">end</span>
</pre>
          </div>
        </div>
      </div>

      <h3 class="section-bar">Public Instance methods</h3>

      <div id="method-M000047" class="method-detail">
        <a name="M000047"></a>

        <div class="method-heading">
          <a href="#M000047" class="method-signature">
          <span class="method-name">a</span><span class="method-args">( phrase, count=nil )</span>
          </a>
        </div>
      
        <div class="method-description">
          <p>
Return the given phrase with the appropriate indefinite article (&quot;<a
href="EN.html#M000047">a</a>&quot; or &quot;<a
href="EN.html#M000048">an</a>&quot;) prepended.
</p>
          <p><a class="source-toggle" href="#"
            onclick="toggleCode('M000047-source');return false;">[Source]</a></p>
          <div class="method-source-code" id="M000047-source">
<pre>
      <span class="ruby-comment cmt"># File lib/linguistics/en.rb, line 1190</span>
1190:     <span class="ruby-keyword kw">def</span> <span class="ruby-identifier">a</span>( <span class="ruby-identifier">phrase</span>, <span class="ruby-identifier">count</span>=<span class="ruby-keyword kw">nil</span> )
1191:         <span class="ruby-identifier">md</span> = <span class="ruby-regexp re">/\A(\s*)(.+?)(\s*)\Z/</span>.<span class="ruby-identifier">match</span>( <span class="ruby-identifier">phrase</span>.<span class="ruby-identifier">to_s</span> )
1192:         <span class="ruby-identifier">pre</span>, <span class="ruby-identifier">word</span>, <span class="ruby-identifier">post</span> = <span class="ruby-identifier">md</span>.<span class="ruby-identifier">to_a</span>[<span class="ruby-value">1</span>,<span class="ruby-value">3</span>]
1193:         <span class="ruby-keyword kw">return</span> <span class="ruby-identifier">phrase</span> <span class="ruby-keyword kw">if</span> <span class="ruby-identifier">word</span>.<span class="ruby-identifier">nil?</span> <span class="ruby-keyword kw">or</span> <span class="ruby-identifier">word</span>.<span class="ruby-identifier">empty?</span>
1194: 
1195:         <span class="ruby-identifier">result</span> = <span class="ruby-identifier">indef_article</span>( <span class="ruby-identifier">word</span>, <span class="ruby-identifier">count</span> )
1196:         <span class="ruby-keyword kw">return</span> <span class="ruby-identifier">pre</span> <span class="ruby-operator">+</span> <span class="ruby-identifier">result</span> <span class="ruby-operator">+</span> <span class="ruby-identifier">post</span>
1197:     <span class="ruby-keyword kw">end</span>
</pre>
          </div>
        </div>
      </div>

      <div id="method-M000048" class="method-detail">
        <a name="M000048"></a>

        <div class="method-heading">
          <span class="method-name">an</span><span class="method-args">( phrase, count=nil )</span>
        </div>
      
        <div class="method-description">
          <p>
Alias for <a href="EN.html#M000047">#a</a>
</p>
        </div>
      </div>

      <div id="method-M000057" class="method-detail">
        <a name="M000057"></a>

        <div class="method-heading">
          <a href="#M000057" class="method-signature">
          <span class="method-name">camel_case_to_english</span><span class="method-args">( string )</span>
          </a>
        </div>
      
        <div class="method-description">
          <p>
Turns <a href="EN.html#M000047">a</a> camel-case <tt>string</tt>
(&quot;camelCaseToEnglish&quot;) to plain English (&quot;camel case to
english&quot;). Each word is decapitalized.
</p>
          <p><a class="source-toggle" href="#"
            onclick="toggleCode('M000057-source');return false;">[Source]</a></p>
          <div class="method-source-code" id="M000057-source">
<pre>
      <span class="ruby-comment cmt"># File lib/linguistics/en.rb, line 1623</span>
1623:     <span class="ruby-keyword kw">def</span> <span class="ruby-identifier">camel_case_to_english</span>( <span class="ruby-identifier">string</span> )
1624:         <span class="ruby-identifier">string</span>.<span class="ruby-identifier">to_s</span>.
1625:             <span class="ruby-identifier">gsub</span>( <span class="ruby-regexp re">/([A-Z])([A-Z])/</span> ) { <span class="ruby-value str">&quot;#$1 #$2&quot;</span> }.
1626:             <span class="ruby-identifier">gsub</span>( <span class="ruby-regexp re">/([a-z])([A-Z])/</span> ) { <span class="ruby-value str">&quot;#$1 #$2&quot;</span> }.<span class="ruby-identifier">downcase</span>
1627:     <span class="ruby-keyword kw">end</span>
</pre>
          </div>
        </div>
      </div>

      <div id="method-M000056" class="method-detail">
        <a name="M000056"></a>

        <div class="method-heading">
          <a href="#M000056" class="method-signature">
          <span class="method-name">conjunction</span><span class="method-args">( obj, args={} ) {|item| ...}</span>
          </a>
        </div>
      
        <div class="method-description">
          <p>
Return the specified <tt>obj</tt> (which must support the <tt>#collect</tt>
method) as <a href="EN.html#M000047">a</a> <a
href="EN.html#M000056">conjunction</a>. Each item is converted to <a
href="EN.html#M000047">a</a> String if it is not already (using #to_s)
unless <a href="EN.html#M000047">a</a> block is given, in which case it is
called once for each object in the array, and the stringified return value
from the block is used instead. Returning <tt>nil</tt> causes that
particular element to be omitted from the resulting <a
href="EN.html#M000056">conjunction</a>. The following options can be used
to control the makeup of the returned <a
href="EN.html#M000056">conjunction</a> String:
</p>
<dl>
<dt><b>:separator</b></dt><dd>Specify one or more characters to separate items in the resulting list.
Defaults to <tt>&#8217;, &#8216;</tt>.

</dd>
<dt><b>:altsep</b></dt><dd>An alternate separator to use if any of the resulting <a
href="EN.html#M000056">conjunction</a>&#8216;s clauses contain the
<tt>:separator</tt> character/s. Defaults to <tt>&#8217;; &#8216;</tt>.

</dd>
<dt><b>:penultimate</b></dt><dd>Flag that indicates whether or not to join the last clause onto the rest of
the <a href="EN.html#M000056">conjunction</a> using <a
href="EN.html#M000047">a</a> penultimate <tt>:separator</tt>. E.g.,

<pre>
  %w{duck, cow, dog}.en.conjunction
  # =&gt; &quot;a duck, a cow, and a dog&quot;
  %w{duck cow dog}.en.conjunction( :penultimate =&gt; false )
  &quot;a duck, a cow and a dog&quot;
</pre>
<p>
Default to <tt>true</tt>.
</p>
</dd>
<dt><b>:conjunctive</b></dt><dd>Sets the word used as the conjunctive (separating word) of the resulting
string. Default to <tt>&#8216;and&#8216;</tt>.

</dd>
<dt><b>:combine</b></dt><dd>If set to <tt>true</tt> (the default), items which are indentical (after
surrounding spaces are stripped) will be combined in the resulting <a
href="EN.html#M000056">conjunction</a>. E.g.,

<pre>
  %w{goose cow goose dog}.en.conjunction
  # =&gt; &quot;two geese, a cow, and a dog&quot;
  %w{goose cow goose dog}.en.conjunction( :combine =&gt; false )
  # =&gt; &quot;a goose, a cow, a goose, and a dog&quot;
</pre>
</dd>
<dt><b>:casefold</b></dt><dd>If set to <tt>true</tt> (the default), then items are compared
case-insensitively when combining them. This has <a
href="EN.html#M000049">no</a> effect if <tt>:combine</tt> is
<tt>false</tt>.

</dd>
<dt><b>:generalize</b></dt><dd>If set to <tt>true</tt>, then quantities of combined items are turned into
general descriptions instead of exact amounts.

<pre>
  ary = %w{goose pig dog horse goose reindeer goose dog horse}
  ary.en.conjunction
  # =&gt; &quot;three geese, two dogs, two horses, a pig, and a reindeer&quot;
  ary.en.conjunction( :generalize =&gt; true )
  # =&gt; &quot;several geese, several dogs, several horses, a pig, and a reindeer&quot;
</pre>
<p>
See the <a href="EN.html#M000055">#quantify</a> method for specifics on how
quantities are generalized. Generalization defaults to <tt>false</tt>, and
has <a href="EN.html#M000049">no</a> effect if :combine is <tt>false</tt>.
</p>
</dd>
<dt><b>:quantsort</b></dt><dd>If set to <tt>true</tt> (the default), items which are combined in the
resulting <a href="EN.html#M000056">conjunction</a> will be listed in order
of amount, with greater quantities sorted first. If <tt>:quantsort</tt> is
<tt>false</tt>, combined items will appear where the first instance of them
occurred in the list. This sort is also the fallback for indentical
quantities (ie., items of the same quantity will be listed in the order
they appeared in the source list).

</dd>
</dl>
          <p><a class="source-toggle" href="#"
            onclick="toggleCode('M000056-source');return false;">[Source]</a></p>
          <div class="method-source-code" id="M000056-source">
<pre>
      <span class="ruby-comment cmt"># File lib/linguistics/en.rb, line 1512</span>
1512:     <span class="ruby-keyword kw">def</span> <span class="ruby-identifier">conjunction</span>( <span class="ruby-identifier">obj</span>, <span class="ruby-identifier">args</span>={} )
1513:         <span class="ruby-identifier">config</span> = <span class="ruby-constant">ConjunctionDefaults</span>.<span class="ruby-identifier">merge</span>( <span class="ruby-identifier">args</span> )
1514:         <span class="ruby-identifier">phrases</span> = []
1515: 
1516:         <span class="ruby-comment cmt"># Transform items in the obj to phrases</span>
1517:         <span class="ruby-keyword kw">if</span> <span class="ruby-identifier">block_given?</span>
1518:             <span class="ruby-identifier">phrases</span> = <span class="ruby-identifier">obj</span>.<span class="ruby-identifier">collect</span> {<span class="ruby-operator">|</span><span class="ruby-identifier">item</span><span class="ruby-operator">|</span> <span class="ruby-keyword kw">yield</span>(<span class="ruby-identifier">item</span>) }.<span class="ruby-identifier">compact</span>
1519:         <span class="ruby-keyword kw">else</span>
1520:             <span class="ruby-identifier">phrases</span> = <span class="ruby-identifier">obj</span>.<span class="ruby-identifier">collect</span> {<span class="ruby-operator">|</span><span class="ruby-identifier">item</span><span class="ruby-operator">|</span> <span class="ruby-identifier">item</span>.<span class="ruby-identifier">to_s</span> }
1521:         <span class="ruby-keyword kw">end</span>
1522: 
1523:         <span class="ruby-comment cmt"># No need for a conjunction if there's only one thing</span>
1524:         <span class="ruby-keyword kw">return</span> <span class="ruby-identifier">a</span>(<span class="ruby-identifier">phrases</span>[<span class="ruby-value">0</span>]) <span class="ruby-keyword kw">if</span> <span class="ruby-identifier">phrases</span>.<span class="ruby-identifier">length</span> <span class="ruby-operator">&lt;</span> <span class="ruby-value">2</span>
1525: 
1526:         <span class="ruby-comment cmt"># Set up a Proc to derive a collector key from a phrase depending on the</span>
1527:         <span class="ruby-comment cmt"># configuration</span>
1528:         <span class="ruby-identifier">keyfunc</span> =
1529:             <span class="ruby-keyword kw">if</span> <span class="ruby-identifier">config</span>[<span class="ruby-identifier">:casefold</span>]
1530:                 <span class="ruby-identifier">proc</span> {<span class="ruby-operator">|</span><span class="ruby-identifier">key</span><span class="ruby-operator">|</span> <span class="ruby-identifier">key</span>.<span class="ruby-identifier">downcase</span>.<span class="ruby-identifier">strip</span>}
1531:             <span class="ruby-keyword kw">else</span>
1532:                 <span class="ruby-identifier">proc</span> {<span class="ruby-operator">|</span><span class="ruby-identifier">key</span><span class="ruby-operator">|</span> <span class="ruby-identifier">key</span>.<span class="ruby-identifier">strip</span>}
1533:             <span class="ruby-keyword kw">end</span>
1534:         
1535:         <span class="ruby-comment cmt"># Count and delete phrases that hash the same when the keyfunc munges</span>
1536:         <span class="ruby-comment cmt"># them into the same thing if we're combining (:combine =&gt; true).</span>
1537:         <span class="ruby-identifier">collector</span> = {}
1538:         <span class="ruby-keyword kw">if</span> <span class="ruby-identifier">config</span>[<span class="ruby-identifier">:combine</span>]
1539:         
1540:             <span class="ruby-identifier">phrases</span>.<span class="ruby-identifier">each_index</span> <span class="ruby-keyword kw">do</span> <span class="ruby-operator">|</span><span class="ruby-identifier">i</span><span class="ruby-operator">|</span>
1541:                 <span class="ruby-comment cmt"># Stop when reaching the end of a truncated list</span>
1542:                 <span class="ruby-keyword kw">break</span> <span class="ruby-keyword kw">if</span> <span class="ruby-identifier">phrases</span>[<span class="ruby-identifier">i</span>].<span class="ruby-identifier">nil?</span>
1543: 
1544:                 <span class="ruby-comment cmt"># Make the key using the configured key function</span>
1545:                 <span class="ruby-identifier">phrase</span> = <span class="ruby-identifier">keyfunc</span>[ <span class="ruby-identifier">phrases</span>[<span class="ruby-identifier">i</span>] ]
1546: 
1547:                 <span class="ruby-comment cmt"># If the collector already has this key, increment its count,</span>
1548:                 <span class="ruby-comment cmt"># eliminate the duplicate from the phrase list, and redo the loop.</span>
1549:                 <span class="ruby-keyword kw">if</span> <span class="ruby-identifier">collector</span>.<span class="ruby-identifier">key?</span>( <span class="ruby-identifier">phrase</span> )
1550:                     <span class="ruby-identifier">collector</span>[ <span class="ruby-identifier">phrase</span> ] <span class="ruby-operator">+=</span> <span class="ruby-value">1</span>
1551:                     <span class="ruby-identifier">phrases</span>.<span class="ruby-identifier">delete_at</span>( <span class="ruby-identifier">i</span> )
1552:                     <span class="ruby-keyword kw">redo</span>
1553:                 <span class="ruby-keyword kw">end</span>
1554: 
1555:                 <span class="ruby-identifier">collector</span>[ <span class="ruby-identifier">phrase</span> ] = <span class="ruby-value">1</span>
1556:             <span class="ruby-keyword kw">end</span>
1557:         <span class="ruby-keyword kw">else</span>
1558:             <span class="ruby-comment cmt"># If we're not combining, just make everything have a count of 1.</span>
1559:             <span class="ruby-identifier">phrases</span>.<span class="ruby-identifier">uniq</span>.<span class="ruby-identifier">each</span> {<span class="ruby-operator">|</span><span class="ruby-identifier">key</span><span class="ruby-operator">|</span> <span class="ruby-identifier">collector</span>[ <span class="ruby-identifier">keyfunc</span>[<span class="ruby-identifier">key</span>] ] = <span class="ruby-value">1</span>}
1560:         <span class="ruby-keyword kw">end</span>
1561: 
1562:         <span class="ruby-comment cmt"># If sort-by-quantity is turned on, sort the phrases first by how many</span>
1563:         <span class="ruby-comment cmt"># there are (most-first), and then by the order they were specified in.</span>
1564:         <span class="ruby-keyword kw">if</span> <span class="ruby-identifier">config</span>[<span class="ruby-identifier">:quantsort</span>] <span class="ruby-operator">&amp;&amp;</span> <span class="ruby-identifier">config</span>[<span class="ruby-identifier">:combine</span>]
1565:             <span class="ruby-identifier">origorder</span> = {}
1566:             <span class="ruby-identifier">phrases</span>.<span class="ruby-identifier">each_with_index</span> {<span class="ruby-operator">|</span><span class="ruby-identifier">phrase</span>,<span class="ruby-identifier">i</span><span class="ruby-operator">|</span> <span class="ruby-identifier">origorder</span>[ <span class="ruby-identifier">keyfunc</span>[<span class="ruby-identifier">phrase</span>] ] <span class="ruby-operator">||=</span> <span class="ruby-identifier">i</span> }
1567:             <span class="ruby-identifier">phrases</span>.<span class="ruby-identifier">sort!</span> {<span class="ruby-operator">|</span><span class="ruby-identifier">a</span>,<span class="ruby-identifier">b</span><span class="ruby-operator">|</span>
1568:                 (<span class="ruby-identifier">collector</span>[ <span class="ruby-identifier">keyfunc</span>[<span class="ruby-identifier">b</span>] ] <span class="ruby-operator">&lt;=&gt;</span> <span class="ruby-identifier">collector</span>[ <span class="ruby-identifier">keyfunc</span>[<span class="ruby-identifier">a</span>] ]).<span class="ruby-identifier">nonzero?</span> <span class="ruby-operator">||</span>
1569:                 (<span class="ruby-identifier">origorder</span>[ <span class="ruby-identifier">keyfunc</span>[<span class="ruby-identifier">a</span>] ] <span class="ruby-operator">&lt;=&gt;</span> <span class="ruby-identifier">origorder</span>[ <span class="ruby-identifier">keyfunc</span>[<span class="ruby-identifier">b</span>] ])
1570:             }
1571:         <span class="ruby-keyword kw">end</span>
1572: 
1573:         <span class="ruby-comment cmt"># Set up a filtering function that adds either an indefinite article, an</span>
1574:         <span class="ruby-comment cmt"># indefinite quantifier, or a definite quantifier to each phrase</span>
1575:         <span class="ruby-comment cmt"># depending on the configuration and the count of phrases in the</span>
1576:         <span class="ruby-comment cmt"># collector.</span>
1577:         <span class="ruby-identifier">filter</span> =
1578:             <span class="ruby-keyword kw">if</span> <span class="ruby-identifier">config</span>[<span class="ruby-identifier">:generalize</span>]
1579:                 <span class="ruby-identifier">proc</span> {<span class="ruby-operator">|</span><span class="ruby-identifier">phrase</span>, <span class="ruby-identifier">count</span><span class="ruby-operator">|</span> <span class="ruby-identifier">quantify</span>(<span class="ruby-identifier">phrase</span>, <span class="ruby-identifier">count</span>) }
1580:             <span class="ruby-keyword kw">else</span>
1581:                 <span class="ruby-identifier">proc</span> {<span class="ruby-operator">|</span><span class="ruby-identifier">phrase</span>, <span class="ruby-identifier">count</span><span class="ruby-operator">|</span>
1582:                 <span class="ruby-keyword kw">if</span> <span class="ruby-identifier">count</span> <span class="ruby-operator">&gt;</span> <span class="ruby-value">1</span>
1583:                     <span class="ruby-value str">&quot;%s %s&quot;</span> <span class="ruby-operator">%</span> [
1584:                         <span class="ruby-comment cmt"># :TODO: Make this threshold settable</span>
1585:                         <span class="ruby-identifier">count</span> <span class="ruby-operator">&lt;</span> <span class="ruby-value">10</span> <span class="ruby-operator">?</span> <span class="ruby-identifier">count</span>.<span class="ruby-identifier">en</span>.<span class="ruby-identifier">numwords</span> <span class="ruby-operator">:</span> <span class="ruby-identifier">count</span>.<span class="ruby-identifier">to_s</span>,
1586:                         <span class="ruby-identifier">plural</span>(<span class="ruby-identifier">phrase</span>, <span class="ruby-identifier">count</span>)
1587:                     ]
1588:                 <span class="ruby-keyword kw">else</span>
1589:                     <span class="ruby-identifier">a</span>( <span class="ruby-identifier">phrase</span> )
1590:                 <span class="ruby-keyword kw">end</span>
1591:             }
1592:             <span class="ruby-keyword kw">end</span>
1593: 
1594:         <span class="ruby-comment cmt"># Now use the configured filter to turn each phrase into its final</span>
1595:         <span class="ruby-comment cmt"># form. Hmmm... square-bracket Lisp?</span>
1596:         <span class="ruby-identifier">phrases</span>.<span class="ruby-identifier">collect!</span> {<span class="ruby-operator">|</span><span class="ruby-identifier">phrase</span><span class="ruby-operator">|</span> <span class="ruby-identifier">filter</span>[<span class="ruby-identifier">phrase</span>, <span class="ruby-identifier">collector</span>[ <span class="ruby-identifier">keyfunc</span>[<span class="ruby-identifier">phrase</span>] ]] }
1597: 
1598:         <span class="ruby-comment cmt"># Prepend the conjunctive to the last element unless it's empty or</span>
1599:         <span class="ruby-comment cmt"># there's only one element</span>
1600:         <span class="ruby-identifier">phrases</span>[<span class="ruby-value">-1</span>].<span class="ruby-identifier">insert</span>( <span class="ruby-value">0</span>, <span class="ruby-identifier">config</span>[<span class="ruby-identifier">:conjunctive</span>] <span class="ruby-operator">+</span> <span class="ruby-value str">&quot; &quot;</span> ) <span class="ruby-keyword kw">unless</span>
1601:             <span class="ruby-identifier">config</span>[<span class="ruby-identifier">:conjunctive</span>].<span class="ruby-identifier">strip</span>.<span class="ruby-identifier">empty?</span> <span class="ruby-keyword kw">or</span>
1602:             <span class="ruby-identifier">phrases</span>.<span class="ruby-identifier">length</span> <span class="ruby-operator">&lt;</span> <span class="ruby-value">2</span>
1603: 
1604:         <span class="ruby-comment cmt"># Concatenate the last two elements if there's no penultimate separator,</span>
1605:         <span class="ruby-comment cmt"># and pick a separator based on how many phrases there are and whether</span>
1606:         <span class="ruby-comment cmt"># or not there's already an instance of it in the phrases.</span>
1607:         <span class="ruby-identifier">phrase_count</span> = <span class="ruby-identifier">phrases</span>.<span class="ruby-identifier">length</span>
1608:         <span class="ruby-identifier">phrases</span>[<span class="ruby-value">-2</span>] <span class="ruby-operator">&lt;&lt;</span> <span class="ruby-value str">&quot; &quot;</span> <span class="ruby-operator">&lt;&lt;</span> <span class="ruby-identifier">phrases</span>.<span class="ruby-identifier">pop</span> <span class="ruby-keyword kw">unless</span> <span class="ruby-identifier">config</span>[<span class="ruby-identifier">:penultimate</span>]
1609:         <span class="ruby-identifier">sep</span> = <span class="ruby-identifier">config</span>[<span class="ruby-identifier">:separator</span>]
1610:         <span class="ruby-keyword kw">if</span> <span class="ruby-identifier">phrase_count</span> <span class="ruby-operator">&lt;=</span> <span class="ruby-value">2</span>
1611:             <span class="ruby-identifier">sep</span> = <span class="ruby-value str">' '</span>
1612:         <span class="ruby-keyword kw">elsif</span> <span class="ruby-identifier">phrases</span>.<span class="ruby-identifier">find</span> {<span class="ruby-operator">|</span><span class="ruby-identifier">str</span><span class="ruby-operator">|</span> <span class="ruby-identifier">str</span>.<span class="ruby-identifier">include?</span>(<span class="ruby-identifier">config</span>[<span class="ruby-identifier">:separator</span>]) }
1613:             <span class="ruby-identifier">sep</span> = <span class="ruby-identifier">config</span>[<span class="ruby-identifier">:altsep</span>]
1614:         <span class="ruby-keyword kw">end</span>
1615: 
1616:         <span class="ruby-keyword kw">return</span> <span class="ruby-identifier">phrases</span>.<span class="ruby-identifier">join</span>( <span class="ruby-identifier">sep</span> )
1617:     <span class="ruby-keyword kw">end</span>
</pre>
          </div>
        </div>
      </div>

      <div id="method-M000058" class="method-detail">
        <a name="M000058"></a>

        <div class="method-heading">
          <a href="#M000058" class="method-signature">
          <span class="method-name">english_to_camel_case</span><span class="method-args">( string )</span>
          </a>
        </div>
      
        <div class="method-description">
          <p>
Turns <a href="EN.html#M000048">an</a> English <a
href="EN.html#M000041">language</a> <tt>string</tt> into <a
href="EN.html#M000047">a</a> CamelCase word.
</p>
          <p><a class="source-toggle" href="#"
            onclick="toggleCode('M000058-source');return false;">[Source]</a></p>
          <div class="method-source-code" id="M000058-source">
<pre>
      <span class="ruby-comment cmt"># File lib/linguistics/en.rb, line 1631</span>
1631:     <span class="ruby-keyword kw">def</span> <span class="ruby-identifier">english_to_camel_case</span>( <span class="ruby-identifier">string</span> )
1632:         <span class="ruby-identifier">string</span>.<span class="ruby-identifier">to_s</span>.<span class="ruby-identifier">gsub</span>( <span class="ruby-regexp re">/\s+([a-z])/</span> ) { <span class="ruby-identifier">$1</span>.<span class="ruby-identifier">upcase</span> }
1633:     <span class="ruby-keyword kw">end</span>
</pre>
          </div>
        </div>
      </div>

      <div id="method-M000035" class="method-detail">
        <a name="M000035"></a>

        <div class="method-heading">
          <a href="#M000035" class="method-signature">
          <span class="method-name">indef_article</span><span class="method-args">( word, count )</span>
          </a>
        </div>
      
        <div class="method-description">
          <p>
Returns the given word with <a href="EN.html#M000047">a</a> prepended
indefinite article, unless <tt>count</tt> is non-nil and not singular.
</p>
          <p><a class="source-toggle" href="#"
            onclick="toggleCode('M000035-source');return false;">[Source]</a></p>
          <div class="method-source-code" id="M000035-source">
<pre>
      <span class="ruby-comment cmt"># File lib/linguistics/en.rb, line 962</span>
 962:     <span class="ruby-keyword kw">def</span> <span class="ruby-identifier">indef_article</span>( <span class="ruby-identifier">word</span>, <span class="ruby-identifier">count</span> )
 963:         <span class="ruby-identifier">count</span> <span class="ruby-operator">||=</span> <span class="ruby-constant">Linguistics</span><span class="ruby-operator">::</span><span class="ruby-identifier">num</span>
 964:         <span class="ruby-keyword kw">return</span> <span class="ruby-node">&quot;#{count} #{word}&quot;</span> <span class="ruby-keyword kw">if</span>
 965:             <span class="ruby-identifier">count</span> <span class="ruby-operator">&amp;&amp;</span> <span class="ruby-node">/^(#{PL_count_one})$/i</span> <span class="ruby-operator">!~</span> <span class="ruby-identifier">count</span>.<span class="ruby-identifier">to_s</span>
 966: 
 967:         <span class="ruby-comment cmt"># Handle user-defined variants</span>
 968:         <span class="ruby-comment cmt"># return value if value = ud_match( word, A_a_user_defined )</span>
 969: 
 970:         <span class="ruby-keyword kw">case</span> <span class="ruby-identifier">word</span>
 971: 
 972:         <span class="ruby-comment cmt"># Handle special cases</span>
 973:         <span class="ruby-keyword kw">when</span> <span class="ruby-node">/^(#{A_explicit_an})/i</span>
 974:             <span class="ruby-keyword kw">return</span> <span class="ruby-node">&quot;an #{word}&quot;</span>
 975: 
 976:         <span class="ruby-comment cmt"># Handle abbreviations</span>
 977:         <span class="ruby-keyword kw">when</span> <span class="ruby-node">/^(#{A_abbrev})/</span><span class="ruby-identifier">x</span>
 978:             <span class="ruby-keyword kw">return</span> <span class="ruby-node">&quot;an #{word}&quot;</span>
 979:         <span class="ruby-keyword kw">when</span> <span class="ruby-regexp re">/^[aefhilmnorsx][.-]/i</span>
 980:             <span class="ruby-keyword kw">return</span> <span class="ruby-node">&quot;an #{word}&quot;</span>
 981:         <span class="ruby-keyword kw">when</span> <span class="ruby-regexp re">/^[a-z][.-]/i</span>    
 982:             <span class="ruby-keyword kw">return</span> <span class="ruby-node">&quot;a #{word}&quot;</span>
 983: 
 984:         <span class="ruby-comment cmt"># Handle consonants</span>
 985:         <span class="ruby-keyword kw">when</span> <span class="ruby-regexp re">/^[^aeiouy]/i</span>
 986:             <span class="ruby-keyword kw">return</span> <span class="ruby-node">&quot;a #{word}&quot;</span>
 987: 
 988:         <span class="ruby-comment cmt"># Handle special vowel-forms</span>
 989:         <span class="ruby-keyword kw">when</span> <span class="ruby-regexp re">/^e[uw]/i</span>    
 990:             <span class="ruby-keyword kw">return</span> <span class="ruby-node">&quot;a #{word}&quot;</span>
 991:         <span class="ruby-keyword kw">when</span> <span class="ruby-regexp re">/^onc?e\b/i</span>  
 992:             <span class="ruby-keyword kw">return</span> <span class="ruby-node">&quot;a #{word}&quot;</span>
 993:         <span class="ruby-keyword kw">when</span> <span class="ruby-regexp re">/^uni([^nmd]|mo)/i</span>
 994:             <span class="ruby-keyword kw">return</span> <span class="ruby-node">&quot;a #{word}&quot;</span>
 995:         <span class="ruby-keyword kw">when</span> <span class="ruby-regexp re">/^u[bcfhjkqrst][aeiou]/i</span>
 996:             <span class="ruby-keyword kw">return</span> <span class="ruby-node">&quot;a #{word}&quot;</span>
 997: 
 998:         <span class="ruby-comment cmt"># Handle vowels</span>
 999:         <span class="ruby-keyword kw">when</span> <span class="ruby-regexp re">/^[aeiou]/i</span>
1000:             <span class="ruby-keyword kw">return</span> <span class="ruby-node">&quot;an #{word}&quot;</span>
1001: 
1002:         <span class="ruby-comment cmt"># Handle y... (before certain consonants implies (unnaturalized) &quot;i..&quot; sound)</span>
1003:         <span class="ruby-keyword kw">when</span> <span class="ruby-node">/^(#{A_y_cons})/i</span>
1004:             <span class="ruby-keyword kw">return</span> <span class="ruby-node">&quot;an #{word}&quot;</span>
1005: 
1006:         <span class="ruby-comment cmt"># Otherwise, guess &quot;a&quot;</span>
1007:         <span class="ruby-keyword kw">else</span>
1008:             <span class="ruby-keyword kw">return</span> <span class="ruby-node">&quot;a #{word}&quot;</span>
1009:         <span class="ruby-keyword kw">end</span>
1010:     <span class="ruby-keyword kw">end</span>
</pre>
          </div>
        </div>
      </div>

      <div id="method-M000020" class="method-detail">
        <a name="M000020"></a>

        <div class="method-heading">
          <a href="#M000020" class="method-signature">
          <span class="method-name">infinitive</span><span class="method-args">( word )</span>
          </a>
        </div>
      
        <div class="method-description">
          <p>
Return the <a href="EN.html#M000020">infinitive</a> form of the given word
</p>
          <p><a class="source-toggle" href="#"
            onclick="toggleCode('M000020-source');return false;">[Source]</a></p>
          <div class="method-source-code" id="M000020-source">
<pre>
      <span class="ruby-comment cmt"># File lib/linguistics/en/infinitive.rb, line 1052</span>
1052:     <span class="ruby-keyword kw">def</span> <span class="ruby-identifier">infinitive</span>( <span class="ruby-identifier">word</span> )
1053:         <span class="ruby-identifier">word</span> = <span class="ruby-identifier">word</span>.<span class="ruby-identifier">to_s</span>
1054:         <span class="ruby-identifier">word1</span> = <span class="ruby-identifier">word2</span> = <span class="ruby-identifier">suffix</span> = <span class="ruby-identifier">rule</span> = <span class="ruby-identifier">newword</span> = <span class="ruby-value str">''</span>
1055: 
1056:         <span class="ruby-keyword kw">if</span> <span class="ruby-constant">IrregularInfinitives</span>.<span class="ruby-identifier">key?</span>( <span class="ruby-identifier">word</span> )
1057:             <span class="ruby-identifier">word1</span>    = <span class="ruby-constant">IrregularInfinitives</span>[ <span class="ruby-identifier">word</span> ]
1058:             <span class="ruby-identifier">rule</span> = <span class="ruby-value str">'irregular'</span>
1059:         <span class="ruby-keyword kw">else</span>
1060:             <span class="ruby-comment cmt"># Build up $prefix{$suffix} as an array of prefixes, from longest to shortest.</span>
1061:             <span class="ruby-identifier">prefix</span>, <span class="ruby-identifier">suffix</span> = <span class="ruby-keyword kw">nil</span>
1062:             <span class="ruby-identifier">prefixes</span> = <span class="ruby-constant">Hash</span><span class="ruby-operator">::</span><span class="ruby-identifier">new</span> {<span class="ruby-operator">|</span><span class="ruby-identifier">hsh</span>,<span class="ruby-identifier">key</span><span class="ruby-operator">|</span> <span class="ruby-identifier">hsh</span>[<span class="ruby-identifier">key</span>] = []}
1063: 
1064:             <span class="ruby-comment cmt"># Build the hash of prefixes for the word</span>
1065:             <span class="ruby-value">1</span>.<span class="ruby-identifier">upto</span>( <span class="ruby-identifier">word</span>.<span class="ruby-identifier">length</span> ) {<span class="ruby-operator">|</span><span class="ruby-identifier">i</span><span class="ruby-operator">|</span>
1066:                 <span class="ruby-identifier">prefix</span> = <span class="ruby-identifier">word</span>[<span class="ruby-value">0</span>, <span class="ruby-identifier">i</span>]
1067:                 <span class="ruby-identifier">suffix</span> = <span class="ruby-identifier">word</span>[<span class="ruby-identifier">i</span><span class="ruby-operator">..</span><span class="ruby-value">-1</span>]
1068: 
1069:                 (<span class="ruby-identifier">suffix</span>.<span class="ruby-identifier">length</span> <span class="ruby-operator">-</span> <span class="ruby-value">1</span>).<span class="ruby-identifier">downto</span>( <span class="ruby-value">0</span> ) {<span class="ruby-operator">|</span><span class="ruby-identifier">j</span><span class="ruby-operator">|</span>
1070:                     <span class="ruby-identifier">newword</span> = <span class="ruby-identifier">prefix</span> <span class="ruby-operator">+</span> <span class="ruby-identifier">suffix</span>[<span class="ruby-value">0</span>, <span class="ruby-identifier">j</span>]
1071:                     <span class="ruby-identifier">prefixes</span>[ <span class="ruby-identifier">suffix</span> ].<span class="ruby-identifier">push</span>( <span class="ruby-identifier">newword</span> )
1072:                 }
1073:             }
1074: 
1075:             <span class="ruby-identifier">$stderr</span>.<span class="ruby-identifier">puts</span> <span class="ruby-value str">&quot;prefixes: %p&quot;</span> <span class="ruby-operator">%</span> <span class="ruby-identifier">prefixes</span> <span class="ruby-keyword kw">if</span> <span class="ruby-identifier">$DEBUG</span>
1076: 
1077:             <span class="ruby-comment cmt"># Now check for rules covering the prefixes for this word, picking</span>
1078:             <span class="ruby-comment cmt"># the first one if one was found.</span>
1079:             <span class="ruby-keyword kw">if</span> (( <span class="ruby-identifier">suffix</span> = ((<span class="ruby-constant">InfSuffixRuleOrder</span> <span class="ruby-operator">&amp;</span> <span class="ruby-identifier">prefixes</span>.<span class="ruby-identifier">keys</span>).<span class="ruby-identifier">first</span>) ))
1080:                 <span class="ruby-identifier">rule</span> = <span class="ruby-constant">InfSuffixRules</span>[ <span class="ruby-identifier">suffix</span> ][<span class="ruby-identifier">:rule</span>]
1081:                 <span class="ruby-identifier">shortestPrefix</span> = <span class="ruby-constant">InfSuffixRules</span>[ <span class="ruby-identifier">suffix</span> ][<span class="ruby-identifier">:word1</span>]
1082:                 <span class="ruby-identifier">$stderr</span>.<span class="ruby-identifier">puts</span> <span class="ruby-value str">&quot;Using rule %p (%p) for suffix %p&quot;</span> <span class="ruby-operator">%</span> 
1083:                     [ <span class="ruby-identifier">rule</span>, <span class="ruby-identifier">shortestPrefix</span>, <span class="ruby-identifier">suffix</span> ] <span class="ruby-keyword kw">if</span> <span class="ruby-identifier">$DEBUG</span>
1084: 
1085:                 <span class="ruby-keyword kw">case</span> <span class="ruby-identifier">shortestPrefix</span>
1086:                 <span class="ruby-keyword kw">when</span> <span class="ruby-value">0</span>
1087:                     <span class="ruby-identifier">word1</span> = <span class="ruby-identifier">prefixes</span>[ <span class="ruby-identifier">suffix</span> ][ <span class="ruby-value">0</span> ]
1088:                     <span class="ruby-identifier">word2</span> = <span class="ruby-identifier">prefixes</span>[ <span class="ruby-identifier">suffix</span> ][ <span class="ruby-value">1</span> ]
1089:                     <span class="ruby-identifier">$stderr</span>.<span class="ruby-identifier">puts</span> <span class="ruby-value str">&quot;For sp = 0: word1: %p, word2: %p&quot;</span> <span class="ruby-operator">%</span>
1090:                         [ <span class="ruby-identifier">word1</span>, <span class="ruby-identifier">word2</span> ] <span class="ruby-keyword kw">if</span> <span class="ruby-identifier">$DEBUG</span>
1091: 
1092:                 <span class="ruby-keyword kw">when</span> <span class="ruby-value">-1</span>
1093:                     <span class="ruby-identifier">word1</span> = <span class="ruby-identifier">prefixes</span>[ <span class="ruby-identifier">suffix</span> ].<span class="ruby-identifier">last</span> <span class="ruby-operator">+</span>
1094:                         <span class="ruby-constant">InfSuffixRules</span>[ <span class="ruby-identifier">suffix</span> ][<span class="ruby-identifier">:suffix1</span>]
1095:                     <span class="ruby-identifier">word2</span> = <span class="ruby-value str">''</span>
1096:                     <span class="ruby-identifier">$stderr</span>.<span class="ruby-identifier">puts</span> <span class="ruby-value str">&quot;For sp = -1: word1: %p, word2: %p&quot;</span> <span class="ruby-operator">%</span>
1097:                         [ <span class="ruby-identifier">word1</span>, <span class="ruby-identifier">word2</span> ] <span class="ruby-keyword kw">if</span> <span class="ruby-identifier">$DEBUG</span>
1098: 
1099:                 <span class="ruby-keyword kw">when</span> <span class="ruby-value">-2</span>
1100:                     <span class="ruby-identifier">word1</span> = <span class="ruby-identifier">prefixes</span>[ <span class="ruby-identifier">suffix</span> ].<span class="ruby-identifier">last</span> <span class="ruby-operator">+</span>
1101:                         <span class="ruby-constant">InfSuffixRules</span>[ <span class="ruby-identifier">suffix</span> ][<span class="ruby-identifier">:suffix1</span>]
1102:                     <span class="ruby-identifier">word2</span> = <span class="ruby-identifier">prefixes</span>[ <span class="ruby-identifier">suffix</span> ].<span class="ruby-identifier">last</span>
1103:                     <span class="ruby-identifier">$stderr</span>.<span class="ruby-identifier">puts</span> <span class="ruby-value str">&quot;For sp = -2: word1: %p, word2: %p&quot;</span> <span class="ruby-operator">%</span>
1104:                         [ <span class="ruby-identifier">word1</span>, <span class="ruby-identifier">word2</span> ] <span class="ruby-keyword kw">if</span> <span class="ruby-identifier">$DEBUG</span>
1105: 
1106:                 <span class="ruby-keyword kw">when</span> <span class="ruby-value">-3</span>
1107:                     <span class="ruby-identifier">word1</span> = <span class="ruby-identifier">prefixes</span>[ <span class="ruby-identifier">suffix</span> ].<span class="ruby-identifier">last</span> <span class="ruby-operator">+</span>
1108:                         <span class="ruby-constant">InfSuffixRules</span>[ <span class="ruby-identifier">suffix</span> ][<span class="ruby-identifier">:suffix1</span>]
1109:                     <span class="ruby-identifier">word2</span> = <span class="ruby-identifier">prefixes</span>[ <span class="ruby-identifier">suffix</span> ].<span class="ruby-identifier">last</span> <span class="ruby-operator">+</span>
1110:                         <span class="ruby-constant">InfSuffixRules</span>[ <span class="ruby-identifier">suffix</span> ][<span class="ruby-identifier">:suffix2</span>]
1111:                     <span class="ruby-identifier">$stderr</span>.<span class="ruby-identifier">puts</span> <span class="ruby-value str">&quot;For sp = -3: word1: %p, word2: %p&quot;</span> <span class="ruby-operator">%</span>
1112:                         [ <span class="ruby-identifier">word1</span>, <span class="ruby-identifier">word2</span> ] <span class="ruby-keyword kw">if</span> <span class="ruby-identifier">$DEBUG</span>
1113: 
1114:                 <span class="ruby-keyword kw">when</span> <span class="ruby-value">-4</span>
1115:                     <span class="ruby-identifier">word1</span> = <span class="ruby-identifier">word</span>
1116:                     <span class="ruby-identifier">word2</span> = <span class="ruby-value str">''</span>
1117:                     <span class="ruby-identifier">$stderr</span>.<span class="ruby-identifier">puts</span> <span class="ruby-value str">&quot;For sp = -4: word1: %p, word2: %p&quot;</span> <span class="ruby-operator">%</span>
1118:                         [ <span class="ruby-identifier">word1</span>, <span class="ruby-identifier">word2</span> ] <span class="ruby-keyword kw">if</span> <span class="ruby-identifier">$DEBUG</span>
1119: 
1120:                 <span class="ruby-keyword kw">else</span>
1121:                     <span class="ruby-identifier">raise</span> <span class="ruby-constant">IndexError</span>,
1122:                         <span class="ruby-value str">&quot;Couldn't find rule for shortest prefix %p&quot;</span> <span class="ruby-operator">%</span>
1123:                         <span class="ruby-identifier">shortestPrefix</span>
1124:                 <span class="ruby-keyword kw">end</span>
1125: 
1126:                 <span class="ruby-comment cmt"># Rules 12b and 15: Strip off 'ed' or 'ing'.</span>
1127:                 <span class="ruby-keyword kw">if</span> <span class="ruby-identifier">rule</span> <span class="ruby-operator">==</span> <span class="ruby-value str">'12b'</span> <span class="ruby-keyword kw">or</span> <span class="ruby-identifier">rule</span> <span class="ruby-operator">==</span> <span class="ruby-value str">'15'</span>
1128:                     <span class="ruby-comment cmt"># Do we have a monosyllable of this form:</span>
1129:                     <span class="ruby-comment cmt"># o 0+ Consonants</span>
1130:                     <span class="ruby-comment cmt"># o 1+ Vowel</span>
1131:                     <span class="ruby-comment cmt"># o    2 Non-wx</span>
1132:                     <span class="ruby-comment cmt"># Eg: tipped =&gt; tipp?</span>
1133:                     <span class="ruby-comment cmt"># Then return tip and tipp.</span>
1134:                     <span class="ruby-comment cmt"># Eg: swimming =&gt; swimm?</span>
1135:                     <span class="ruby-comment cmt"># Then return tipswim and swimm.</span>
1136: 
1137:                     <span class="ruby-keyword kw">if</span> <span class="ruby-regexp re">/^([^aeiou]*[aeiou]+)([^wx])\2$/</span> <span class="ruby-operator">=~</span> <span class="ruby-identifier">word2</span>
1138:                         <span class="ruby-identifier">word1</span> = <span class="ruby-identifier">$1</span> <span class="ruby-operator">+</span> <span class="ruby-identifier">$2</span>
1139:                         <span class="ruby-identifier">word2</span> = <span class="ruby-identifier">$1</span> <span class="ruby-operator">+</span> <span class="ruby-identifier">$2</span> <span class="ruby-operator">+</span> <span class="ruby-identifier">$2</span>
1140:                     <span class="ruby-keyword kw">end</span>
1141:                 <span class="ruby-keyword kw">end</span>
1142:             <span class="ruby-keyword kw">end</span>
1143:         <span class="ruby-keyword kw">end</span>
1144: 
1145:         <span class="ruby-keyword kw">return</span> <span class="ruby-constant">Infinitive</span><span class="ruby-operator">::</span><span class="ruby-identifier">new</span>( <span class="ruby-identifier">word1</span>, <span class="ruby-identifier">word2</span>, <span class="ruby-identifier">suffix</span>, <span class="ruby-identifier">rule</span> )
1146:     <span class="ruby-keyword kw">end</span>
</pre>
          </div>
        </div>
      </div>

      <div id="method-M000041" class="method-detail">
        <a name="M000041"></a>

        <div class="method-heading">
          <a href="#M000041" class="method-signature">
          <span class="method-name">language</span><span class="method-args">( unused=nil )</span>
          </a>
        </div>
      
        <div class="method-description">
          <p>
Return the name of the <a href="EN.html#M000041">language</a> this module
is for.
</p>
          <p><a class="source-toggle" href="#"
            onclick="toggleCode('M000041-source');return false;">[Source]</a></p>
          <div class="method-source-code" id="M000041-source">
<pre>
      <span class="ruby-comment cmt"># File lib/linguistics/en.rb, line 1121</span>
1121:     <span class="ruby-keyword kw">def</span> <span class="ruby-identifier">language</span>( <span class="ruby-identifier">unused</span>=<span class="ruby-keyword kw">nil</span> )
1122:         <span class="ruby-value str">&quot;English&quot;</span>
1123:     <span class="ruby-keyword kw">end</span>
</pre>
          </div>
        </div>
      </div>

      <div id="method-M000060" class="method-detail">
        <a name="M000060"></a>

        <div class="method-heading">
          <a href="#M000060" class="method-signature">
          <span class="method-name">lprintf</span><span class="method-args">( fmt, *args )</span>
          </a>
        </div>
      
        <div class="method-description">
          <p>
Format the given <tt>fmt</tt> string by replacing %-escaped sequences with
the result of performing <a href="EN.html#M000047">a</a> specified
operation on the corresponding argument, ala Kernel.sprintf.
</p>
<table>
<tr><td valign="top">%PL:</td><td>Plural.

</td></tr>
<tr><td valign="top">%A, %AN:</td><td>Prepend indefinite article.

</td></tr>
<tr><td valign="top">%NO:</td><td>Zero-quantified phrase.

</td></tr>
<tr><td valign="top">%NUMWORDS:</td><td>Convert <a href="EN.html#M000047">a</a> number into the corresponding
words.

</td></tr>
<tr><td valign="top">%CONJUNCT:</td><td>Conjunction.

</td></tr>
</table>
          <p><a class="source-toggle" href="#"
            onclick="toggleCode('M000060-source');return false;">[Source]</a></p>
          <div class="method-source-code" id="M000060-source">
<pre>
      <span class="ruby-comment cmt"># File lib/linguistics/en.rb, line 1706</span>
1706:     <span class="ruby-keyword kw">def</span> <span class="ruby-identifier">lprintf</span>( <span class="ruby-identifier">fmt</span>, <span class="ruby-operator">*</span><span class="ruby-identifier">args</span> )
1707:         <span class="ruby-identifier">fmt</span>.<span class="ruby-identifier">to_s</span>.<span class="ruby-identifier">gsub</span>( <span class="ruby-regexp re">/%([A-Z_]+)/</span> ) <span class="ruby-keyword kw">do</span> <span class="ruby-operator">|</span><span class="ruby-identifier">match</span><span class="ruby-operator">|</span>
1708:             <span class="ruby-identifier">op</span> = <span class="ruby-identifier">$1</span>.<span class="ruby-identifier">to_s</span>.<span class="ruby-identifier">upcase</span>.<span class="ruby-identifier">to_sym</span>
1709:             <span class="ruby-keyword kw">if</span> <span class="ruby-keyword kw">self</span>.<span class="ruby-identifier">lprintf_formatters</span>.<span class="ruby-identifier">key?</span>( <span class="ruby-identifier">op</span> )
1710:                 <span class="ruby-identifier">arg</span> = <span class="ruby-identifier">args</span>.<span class="ruby-identifier">shift</span>
1711:                 <span class="ruby-keyword kw">self</span>.<span class="ruby-identifier">lprintf_formatters</span>[ <span class="ruby-identifier">op</span> ].<span class="ruby-identifier">call</span>( <span class="ruby-identifier">arg</span> )
1712:             <span class="ruby-keyword kw">else</span>
1713:                 <span class="ruby-identifier">raise</span> <span class="ruby-value str">&quot;no such formatter %p&quot;</span> <span class="ruby-operator">%</span> <span class="ruby-identifier">op</span>
1714:             <span class="ruby-keyword kw">end</span>
1715:         <span class="ruby-keyword kw">end</span>
1716:     <span class="ruby-keyword kw">end</span>
</pre>
          </div>
        </div>
      </div>

      <div id="method-M000049" class="method-detail">
        <a name="M000049"></a>

        <div class="method-heading">
          <a href="#M000049" class="method-signature">
          <span class="method-name">no</span><span class="method-args">( phrase, count=nil )</span>
          </a>
        </div>
      
        <div class="method-description">
          <p>
Translate zero-quantified <tt>phrase</tt> to &quot;<a
href="EN.html#M000049">no</a> +phrase.plural+&quot;
</p>
          <p><a class="source-toggle" href="#"
            onclick="toggleCode('M000049-source');return false;">[Source]</a></p>
          <div class="method-source-code" id="M000049-source">
<pre>
      <span class="ruby-comment cmt"># File lib/linguistics/en.rb, line 1204</span>
1204:     <span class="ruby-keyword kw">def</span> <span class="ruby-identifier">no</span>( <span class="ruby-identifier">phrase</span>, <span class="ruby-identifier">count</span>=<span class="ruby-keyword kw">nil</span> )
1205:         <span class="ruby-identifier">md</span> = <span class="ruby-regexp re">/\A(\s*)(.+?)(\s*)\Z/</span>.<span class="ruby-identifier">match</span>( <span class="ruby-identifier">phrase</span>.<span class="ruby-identifier">to_s</span> )
1206:         <span class="ruby-identifier">pre</span>, <span class="ruby-identifier">word</span>, <span class="ruby-identifier">post</span> = <span class="ruby-identifier">md</span>.<span class="ruby-identifier">to_a</span>[<span class="ruby-value">1</span>,<span class="ruby-value">3</span>]
1207:         <span class="ruby-identifier">count</span> <span class="ruby-operator">||=</span> <span class="ruby-constant">Linguistics</span><span class="ruby-operator">::</span><span class="ruby-identifier">num</span> <span class="ruby-operator">||</span> <span class="ruby-value">0</span>
1208: 
1209:         <span class="ruby-keyword kw">unless</span> <span class="ruby-node">/^#{PL_count_zero}$/</span> <span class="ruby-operator">=~</span> <span class="ruby-identifier">count</span>.<span class="ruby-identifier">to_s</span>
1210:             <span class="ruby-keyword kw">return</span> <span class="ruby-node">&quot;#{pre}#{count} &quot;</span> <span class="ruby-operator">+</span> <span class="ruby-identifier">plural</span>( <span class="ruby-identifier">word</span>, <span class="ruby-identifier">count</span> ) <span class="ruby-operator">+</span> <span class="ruby-identifier">post</span>
1211:         <span class="ruby-keyword kw">else</span>
1212:             <span class="ruby-keyword kw">return</span> <span class="ruby-node">&quot;#{pre}no &quot;</span> <span class="ruby-operator">+</span> <span class="ruby-identifier">plural</span>( <span class="ruby-identifier">word</span>, <span class="ruby-value">0</span> ) <span class="ruby-operator">+</span> <span class="ruby-identifier">post</span>
1213:         <span class="ruby-keyword kw">end</span>
1214:     <span class="ruby-keyword kw">end</span>
</pre>
          </div>
        </div>
      </div>

      <div id="method-M000029" class="method-detail">
        <a name="M000029"></a>

        <div class="method-heading">
          <a href="#M000029" class="method-signature">
          <span class="method-name">normalize_count</span><span class="method-args">( count, default=2 )</span>
          </a>
        </div>
      
        <div class="method-description">
          <p>
Normalize <a href="EN.html#M000047">a</a> count to either 1 or 2 (singular
or <a href="EN.html#M000042">plural</a>)
</p>
          <p><a class="source-toggle" href="#"
            onclick="toggleCode('M000029-source');return false;">[Source]</a></p>
          <div class="method-source-code" id="M000029-source">
<pre>
     <span class="ruby-comment cmt"># File lib/linguistics/en.rb, line 691</span>
691:     <span class="ruby-keyword kw">def</span> <span class="ruby-identifier">normalize_count</span>( <span class="ruby-identifier">count</span>, <span class="ruby-identifier">default</span>=<span class="ruby-value">2</span> )
692:         <span class="ruby-keyword kw">return</span> <span class="ruby-identifier">default</span> <span class="ruby-keyword kw">if</span> <span class="ruby-identifier">count</span>.<span class="ruby-identifier">nil?</span> <span class="ruby-comment cmt"># Default to plural</span>
693:         <span class="ruby-keyword kw">if</span> <span class="ruby-node">/^(#{PL_count_one})$/i</span> <span class="ruby-operator">=~</span> <span class="ruby-identifier">count</span>.<span class="ruby-identifier">to_s</span> <span class="ruby-operator">||</span>
694:                 <span class="ruby-constant">Linguistics</span><span class="ruby-operator">::</span><span class="ruby-identifier">classical?</span> <span class="ruby-operator">&amp;&amp;</span>
695:                 <span class="ruby-node">/^(#{PL_count_zero})$/</span> <span class="ruby-operator">=~</span> <span class="ruby-identifier">count</span>.<span class="ruby-identifier">to_s</span>
696:             <span class="ruby-keyword kw">return</span> <span class="ruby-value">1</span>
697:         <span class="ruby-keyword kw">else</span>
698:             <span class="ruby-keyword kw">return</span> <span class="ruby-identifier">default</span>
699:         <span class="ruby-keyword kw">end</span>
700:     <span class="ruby-keyword kw">end</span>
</pre>
          </div>
        </div>
      </div>

      <div id="method-M000040" class="method-detail">
        <a name="M000040"></a>

        <div class="method-heading">
          <a href="#M000040" class="method-signature">
          <span class="method-name">number_to_words</span><span class="method-args">( num, config )</span>
          </a>
        </div>
      
        <div class="method-description">
          <p>
Return the specified number <tt>num</tt> as <a
href="EN.html#M000048">an</a> array of number phrases.
</p>
          <p><a class="source-toggle" href="#"
            onclick="toggleCode('M000040-source');return false;">[Source]</a></p>
          <div class="method-source-code" id="M000040-source">
<pre>
      <span class="ruby-comment cmt"># File lib/linguistics/en.rb, line 1067</span>
1067:     <span class="ruby-keyword kw">def</span> <span class="ruby-identifier">number_to_words</span>( <span class="ruby-identifier">num</span>, <span class="ruby-identifier">config</span> )
1068:         <span class="ruby-keyword kw">return</span> [<span class="ruby-identifier">config</span>[<span class="ruby-identifier">:zero</span>]] <span class="ruby-keyword kw">if</span> <span class="ruby-identifier">num</span>.<span class="ruby-identifier">to_i</span>.<span class="ruby-identifier">zero?</span>
1069:         <span class="ruby-identifier">chunks</span> = []
1070: 
1071:         <span class="ruby-comment cmt"># Break into word-groups if groups is set</span>
1072:         <span class="ruby-keyword kw">if</span> <span class="ruby-identifier">config</span>[<span class="ruby-identifier">:group</span>].<span class="ruby-identifier">nonzero?</span>
1073: 
1074:             <span class="ruby-comment cmt"># Build a Regexp with &lt;config[:group]&gt; number of digits. Any past</span>
1075:             <span class="ruby-comment cmt"># the first are optional.</span>
1076:             <span class="ruby-identifier">re</span> = <span class="ruby-constant">Regexp</span><span class="ruby-operator">::</span><span class="ruby-identifier">new</span>( <span class="ruby-value str">&quot;(\\d)&quot;</span> <span class="ruby-operator">+</span> (<span class="ruby-value str">&quot;(\\d)?&quot;</span> <span class="ruby-operator">*</span> (<span class="ruby-identifier">config</span>[<span class="ruby-identifier">:group</span>] <span class="ruby-operator">-</span> <span class="ruby-value">1</span>)) )
1077: 
1078:             <span class="ruby-comment cmt"># Scan the string, and call the word-chunk function that deals with</span>
1079:             <span class="ruby-comment cmt"># chunks of the found number of digits.</span>
1080:             <span class="ruby-identifier">num</span>.<span class="ruby-identifier">to_s</span>.<span class="ruby-identifier">scan</span>( <span class="ruby-identifier">re</span> ) {<span class="ruby-operator">|</span><span class="ruby-identifier">digits</span><span class="ruby-operator">|</span>
1081:                 <span class="ruby-identifier">debug_msg</span> <span class="ruby-node">&quot;   digits = #{digits.inspect}&quot;</span>
1082:                 <span class="ruby-identifier">fn</span> = <span class="ruby-constant">NumberToWordsFunctions</span>[ <span class="ruby-identifier">digits</span>.<span class="ruby-identifier">nitems</span> ]
1083:                 <span class="ruby-identifier">numerals</span> = <span class="ruby-identifier">digits</span>.<span class="ruby-identifier">flatten</span>.<span class="ruby-identifier">compact</span>.<span class="ruby-identifier">collect</span> {<span class="ruby-operator">|</span><span class="ruby-identifier">i</span><span class="ruby-operator">|</span> <span class="ruby-identifier">i</span>.<span class="ruby-identifier">to_i</span>}
1084:                 <span class="ruby-identifier">debug_msg</span> <span class="ruby-node">&quot;   numerals = #{numerals.inspect}&quot;</span>
1085:                 <span class="ruby-identifier">chunks</span>.<span class="ruby-identifier">push</span> <span class="ruby-identifier">fn</span>.<span class="ruby-identifier">call</span>( <span class="ruby-identifier">config</span>[<span class="ruby-identifier">:zero</span>], <span class="ruby-operator">*</span><span class="ruby-identifier">numerals</span> ).<span class="ruby-identifier">strip</span>
1086:             }
1087:         <span class="ruby-keyword kw">else</span>
1088:             <span class="ruby-identifier">phrase</span> = <span class="ruby-identifier">num</span>.<span class="ruby-identifier">to_s</span>
1089:             <span class="ruby-identifier">phrase</span>.<span class="ruby-identifier">sub!</span>( <span class="ruby-regexp re">/\A\s*0+/</span>, <span class="ruby-value str">''</span> )
1090:             <span class="ruby-identifier">mill</span> = <span class="ruby-value">0</span>
1091: 
1092:             <span class="ruby-comment cmt"># Match backward from the end of the digits in the string, turning</span>
1093:             <span class="ruby-comment cmt"># chunks of three, of two, and of one into words.</span>
1094:             <span class="ruby-identifier">mill</span> <span class="ruby-operator">+=</span> <span class="ruby-value">1</span> <span class="ruby-keyword kw">while</span>
1095:                 <span class="ruby-identifier">phrase</span>.<span class="ruby-identifier">sub!</span>( <span class="ruby-regexp re">/(\d)(\d)(\d)(?=\D*\Z)/</span> ) {
1096:                     <span class="ruby-identifier">words</span> = <span class="ruby-identifier">to_hundreds</span>( <span class="ruby-identifier">$1</span>.<span class="ruby-identifier">to_i</span>, <span class="ruby-identifier">$2</span>.<span class="ruby-identifier">to_i</span>, <span class="ruby-identifier">$3</span>.<span class="ruby-identifier">to_i</span>, <span class="ruby-identifier">mill</span>, 
1097:                                          <span class="ruby-identifier">config</span>[<span class="ruby-identifier">:and</span>] )
1098:                     <span class="ruby-identifier">chunks</span>.<span class="ruby-identifier">unshift</span> <span class="ruby-identifier">words</span>.<span class="ruby-identifier">strip</span>.<span class="ruby-identifier">squeeze</span>(<span class="ruby-value str">' '</span>) <span class="ruby-keyword kw">unless</span> <span class="ruby-identifier">words</span>.<span class="ruby-identifier">nil?</span>
1099:                     <span class="ruby-value str">''</span>
1100:                 }               
1101: 
1102:             <span class="ruby-identifier">phrase</span>.<span class="ruby-identifier">sub!</span>( <span class="ruby-regexp re">/(\d)(\d)(?=\D*\Z)/</span> ) {
1103:                 <span class="ruby-identifier">chunks</span>.<span class="ruby-identifier">unshift</span> <span class="ruby-identifier">to_tens</span>( <span class="ruby-identifier">$1</span>.<span class="ruby-identifier">to_i</span>, <span class="ruby-identifier">$2</span>.<span class="ruby-identifier">to_i</span>, <span class="ruby-identifier">mill</span> ).<span class="ruby-identifier">strip</span>.<span class="ruby-identifier">squeeze</span>(<span class="ruby-value str">' '</span>)
1104:                 <span class="ruby-value str">''</span>
1105:             }
1106:             <span class="ruby-identifier">phrase</span>.<span class="ruby-identifier">sub!</span>( <span class="ruby-regexp re">/(\d)(?=\D*\Z)/</span> ) {
1107:                 <span class="ruby-identifier">chunks</span>.<span class="ruby-identifier">unshift</span> <span class="ruby-identifier">to_units</span>( <span class="ruby-identifier">$1</span>.<span class="ruby-identifier">to_i</span>, <span class="ruby-identifier">mill</span> ).<span class="ruby-identifier">strip</span>.<span class="ruby-identifier">squeeze</span>(<span class="ruby-value str">' '</span>)
1108:                 <span class="ruby-value str">''</span>
1109:             }
1110:         <span class="ruby-keyword kw">end</span>
1111: 
1112:         <span class="ruby-keyword kw">return</span> <span class="ruby-identifier">chunks</span>
1113:     <span class="ruby-keyword kw">end</span>
</pre>
          </div>
        </div>
      </div>

      <div id="method-M000052" class="method-detail">
        <a name="M000052"></a>

        <div class="method-heading">
          <a href="#M000052" class="method-signature">
          <span class="method-name">numwords</span><span class="method-args">( number, hashargs={} )</span>
          </a>
        </div>
      
        <div class="method-description">
          <p>
Return the specified number as english words. One or more configuration
values may be passed to control the returned String:
</p>
<dl>
<dt><b>:group</b></dt><dd>Controls how many numbers at <a href="EN.html#M000047">a</a> time are
grouped together. Valid values are <tt>0</tt> (normal grouping), <tt>1</tt>
(single-digit grouping, e.g., &quot;one, two, three, four&quot;),
<tt>2</tt> (double-digit grouping, e.g., &quot;twelve, thirty-four&quot;,
or <tt>3</tt> (triple-digit grouping, e.g., &quot;one twenty-three,
four&quot;).

</dd>
<dt><b>:comma</b></dt><dd>Set the character/s used to separate word groups. Defaults to <tt>&quot;,
&quot;</tt>.

</dd>
<dt><b>:and</b></dt><dd>Set the word and/or characters used where <tt>&#8217; and &#8217; </tt>(the
default) is normally used. Setting <tt>:and</tt> to <tt>&#8217;
&#8216;</tt>, for example, will cause <tt>2556</tt> to be returned as
&quot;two-thousand, five hundred fifty-six&quot; instead of
&quot;two-thousand, five hundred and fifty-six&quot;.

</dd>
<dt><b>:zero</b></dt><dd>Set the word used to represent the numeral <tt>0</tt> in the result.
<tt>&#8216;zero&#8216;</tt> is the default.

</dd>
<dt><b>:decimal</b></dt><dd>Set the translation of any decimal points in the number; the default is
<tt>&#8216;point&#8216;</tt>.

</dd>
<dt><b>:asArray</b></dt><dd>If set to <a href="EN.html#M000047">a</a> true value, the number will be
returned as <a href="EN.html#M000048">an</a> array of word groups instead
of <a href="EN.html#M000047">a</a> String.

</dd>
</dl>
          <p><a class="source-toggle" href="#"
            onclick="toggleCode('M000052-source');return false;">[Source]</a></p>
          <div class="method-source-code" id="M000052-source">
<pre>
      <span class="ruby-comment cmt"># File lib/linguistics/en.rb, line 1264</span>
1264:     <span class="ruby-keyword kw">def</span> <span class="ruby-identifier">numwords</span>( <span class="ruby-identifier">number</span>, <span class="ruby-identifier">hashargs</span>={} )
1265:         <span class="ruby-identifier">num</span> = <span class="ruby-identifier">number</span>.<span class="ruby-identifier">to_s</span>
1266:         <span class="ruby-identifier">config</span> = <span class="ruby-constant">NumwordDefaults</span>.<span class="ruby-identifier">merge</span>( <span class="ruby-identifier">hashargs</span> )
1267:         <span class="ruby-identifier">raise</span> <span class="ruby-node">&quot;Bad chunking option: #{config[:group]}&quot;</span> <span class="ruby-keyword kw">unless</span>
1268:             <span class="ruby-identifier">config</span>[<span class="ruby-identifier">:group</span>].<span class="ruby-identifier">between?</span>( <span class="ruby-value">0</span>, <span class="ruby-value">3</span> )
1269: 
1270:         <span class="ruby-comment cmt"># Array of number parts: first is everything to the left of the first</span>
1271:         <span class="ruby-comment cmt"># decimal, followed by any groups of decimal-delimted numbers after that</span>
1272:         <span class="ruby-identifier">parts</span> = []
1273: 
1274:         <span class="ruby-comment cmt"># Wordify any sign prefix</span>
1275:         <span class="ruby-identifier">sign</span> = (<span class="ruby-regexp re">/\A\s*\+/</span> <span class="ruby-operator">=~</span> <span class="ruby-identifier">num</span>) <span class="ruby-operator">?</span> <span class="ruby-value str">'plus'</span> <span class="ruby-operator">:</span> (<span class="ruby-regexp re">/\A\s*\-/</span> <span class="ruby-operator">=~</span> <span class="ruby-identifier">num</span>) <span class="ruby-operator">?</span> <span class="ruby-value str">'minus'</span> <span class="ruby-operator">:</span> <span class="ruby-value str">''</span>
1276: 
1277:         <span class="ruby-comment cmt"># Strip any ordinal suffixes</span>
1278:         <span class="ruby-identifier">ord</span> = <span class="ruby-keyword kw">true</span> <span class="ruby-keyword kw">if</span> <span class="ruby-identifier">num</span>.<span class="ruby-identifier">sub!</span>( <span class="ruby-regexp re">/(st|nd|rd|th)\Z/</span>, <span class="ruby-value str">''</span> )
1279: 
1280:         <span class="ruby-comment cmt"># Split the number into chunks delimited by '.'</span>
1281:         <span class="ruby-identifier">chunks</span> = <span class="ruby-keyword kw">if</span> <span class="ruby-operator">!</span><span class="ruby-identifier">config</span>[<span class="ruby-identifier">:decimal</span>].<span class="ruby-identifier">empty?</span> <span class="ruby-keyword kw">then</span>
1282:                      <span class="ruby-keyword kw">if</span> <span class="ruby-identifier">config</span>[<span class="ruby-identifier">:group</span>].<span class="ruby-identifier">nonzero?</span>
1283:                          <span class="ruby-identifier">num</span>.<span class="ruby-identifier">split</span>(<span class="ruby-regexp re">/\./</span>)
1284:                      <span class="ruby-keyword kw">else</span>
1285:                          <span class="ruby-identifier">num</span>.<span class="ruby-identifier">split</span>(<span class="ruby-regexp re">/\./</span>, <span class="ruby-value">2</span>)
1286:                      <span class="ruby-keyword kw">end</span>
1287:                  <span class="ruby-keyword kw">else</span>
1288:                      [ <span class="ruby-identifier">num</span> ]
1289:                  <span class="ruby-keyword kw">end</span>
1290: 
1291:         <span class="ruby-comment cmt"># Wordify each chunk, pushing arrays into the parts array</span>
1292:         <span class="ruby-identifier">chunks</span>.<span class="ruby-identifier">each_with_index</span> {<span class="ruby-operator">|</span><span class="ruby-identifier">chunk</span>,<span class="ruby-identifier">section</span><span class="ruby-operator">|</span>
1293:             <span class="ruby-identifier">chunk</span>.<span class="ruby-identifier">gsub!</span>( <span class="ruby-regexp re">/\D+/</span>, <span class="ruby-value str">''</span> )
1294: 
1295:             <span class="ruby-comment cmt"># If there's nothing in this chunk of the number, set it to zero</span>
1296:             <span class="ruby-comment cmt"># unless it's the whole-number part, in which case just push an</span>
1297:             <span class="ruby-comment cmt"># empty array.</span>
1298:             <span class="ruby-keyword kw">if</span> <span class="ruby-identifier">chunk</span>.<span class="ruby-identifier">empty?</span>
1299:                 <span class="ruby-keyword kw">if</span> <span class="ruby-identifier">section</span>.<span class="ruby-identifier">zero?</span>
1300:                     <span class="ruby-identifier">parts</span>.<span class="ruby-identifier">push</span> []
1301:                     <span class="ruby-keyword kw">next</span> 
1302:                 <span class="ruby-keyword kw">end</span>
1303:             <span class="ruby-keyword kw">end</span>
1304: 
1305:             <span class="ruby-comment cmt"># Split the number section into wordified parts unless this is the</span>
1306:             <span class="ruby-comment cmt"># second or succeeding part of a non-group number</span>
1307:             <span class="ruby-keyword kw">unless</span> <span class="ruby-identifier">config</span>[<span class="ruby-identifier">:group</span>].<span class="ruby-identifier">zero?</span> <span class="ruby-operator">&amp;&amp;</span> <span class="ruby-identifier">section</span>.<span class="ruby-identifier">nonzero?</span>
1308:                 <span class="ruby-identifier">parts</span>.<span class="ruby-identifier">push</span> <span class="ruby-identifier">number_to_words</span>( <span class="ruby-identifier">chunk</span>, <span class="ruby-identifier">config</span> )
1309:             <span class="ruby-keyword kw">else</span>
1310:                 <span class="ruby-identifier">parts</span>.<span class="ruby-identifier">push</span> <span class="ruby-identifier">number_to_words</span>( <span class="ruby-identifier">chunk</span>, <span class="ruby-identifier">config</span>.<span class="ruby-identifier">merge</span>(<span class="ruby-identifier">:group</span> =<span class="ruby-operator">&gt;</span> <span class="ruby-value">1</span>) )
1311:             <span class="ruby-keyword kw">end</span>                  
1312:         }
1313: 
1314:         <span class="ruby-identifier">debug_msg</span> <span class="ruby-node">&quot;Parts =&gt; #{parts.inspect}&quot;</span>
1315:         
1316:         <span class="ruby-comment cmt"># Turn the last word of the whole-number part back into an ordinal if</span>
1317:         <span class="ruby-comment cmt"># the original number came in that way.</span>
1318:         <span class="ruby-keyword kw">if</span> <span class="ruby-identifier">ord</span> <span class="ruby-operator">&amp;&amp;</span> <span class="ruby-operator">!</span><span class="ruby-identifier">parts</span>[<span class="ruby-value">0</span>].<span class="ruby-identifier">empty?</span>
1319:             <span class="ruby-identifier">parts</span>[<span class="ruby-value">0</span>][<span class="ruby-value">-1</span>] = <span class="ruby-identifier">ordinal</span>( <span class="ruby-identifier">parts</span>[<span class="ruby-value">0</span>].<span class="ruby-identifier">last</span> )
1320:         <span class="ruby-keyword kw">end</span>
1321: 
1322:         <span class="ruby-comment cmt"># If the caller's expecting an Array return, just flatten and return the</span>
1323:         <span class="ruby-comment cmt"># parts array.</span>
1324:         <span class="ruby-keyword kw">if</span> <span class="ruby-identifier">config</span>[<span class="ruby-identifier">:asArray</span>]
1325:             <span class="ruby-keyword kw">unless</span> <span class="ruby-identifier">sign</span>.<span class="ruby-identifier">empty?</span>
1326:                 <span class="ruby-identifier">parts</span>[<span class="ruby-value">0</span>].<span class="ruby-identifier">unshift</span>( <span class="ruby-identifier">sign</span> )
1327:             <span class="ruby-keyword kw">end</span>
1328:             <span class="ruby-keyword kw">return</span> <span class="ruby-identifier">parts</span>.<span class="ruby-identifier">flatten</span>
1329:         <span class="ruby-keyword kw">end</span>
1330: 
1331:         <span class="ruby-comment cmt"># Catenate each sub-parts array into a whole number part and one or more</span>
1332:         <span class="ruby-comment cmt"># post-decimal parts. If grouping is turned on, all sub-parts get joined</span>
1333:         <span class="ruby-comment cmt"># with commas, otherwise just the whole-number part is.</span>
1334:         <span class="ruby-keyword kw">if</span> <span class="ruby-identifier">config</span>[<span class="ruby-identifier">:group</span>].<span class="ruby-identifier">zero?</span>
1335:             <span class="ruby-keyword kw">if</span> <span class="ruby-identifier">parts</span>[<span class="ruby-value">0</span>].<span class="ruby-identifier">nitems</span> <span class="ruby-operator">&gt;</span> <span class="ruby-value">1</span>
1336: 
1337:                 <span class="ruby-comment cmt"># Join all but the last part together with commas</span>
1338:                 <span class="ruby-identifier">wholenum</span> = <span class="ruby-identifier">parts</span>[<span class="ruby-value">0</span>][<span class="ruby-value">0</span><span class="ruby-operator">...</span><span class="ruby-value">-1</span>].<span class="ruby-identifier">join</span>( <span class="ruby-identifier">config</span>[<span class="ruby-identifier">:comma</span>] )
1339: 
1340:                 <span class="ruby-comment cmt"># If the last part is just a single word, append it to the</span>
1341:                 <span class="ruby-comment cmt"># wholenum part with an 'and'. This is to get things like 'three</span>
1342:                 <span class="ruby-comment cmt"># thousand and three' instead of 'three thousand, three'.</span>
1343:                 <span class="ruby-keyword kw">if</span> <span class="ruby-regexp re">/^\s*(\S+)\s*$/</span> <span class="ruby-operator">=~</span> <span class="ruby-identifier">parts</span>[<span class="ruby-value">0</span>].<span class="ruby-identifier">last</span>
1344:                     <span class="ruby-identifier">wholenum</span> <span class="ruby-operator">+=</span> <span class="ruby-identifier">config</span>[<span class="ruby-identifier">:and</span>] <span class="ruby-operator">+</span> <span class="ruby-identifier">parts</span>[<span class="ruby-value">0</span>].<span class="ruby-identifier">last</span>
1345:                 <span class="ruby-keyword kw">else</span>
1346:                     <span class="ruby-identifier">wholenum</span> <span class="ruby-operator">+=</span> <span class="ruby-identifier">config</span>[<span class="ruby-identifier">:comma</span>] <span class="ruby-operator">+</span> <span class="ruby-identifier">parts</span>[<span class="ruby-value">0</span>].<span class="ruby-identifier">last</span>
1347:                 <span class="ruby-keyword kw">end</span>
1348:             <span class="ruby-keyword kw">else</span>
1349:                 <span class="ruby-identifier">wholenum</span> = <span class="ruby-identifier">parts</span>[<span class="ruby-value">0</span>][<span class="ruby-value">0</span>]
1350:             <span class="ruby-keyword kw">end</span>
1351:             <span class="ruby-identifier">decimals</span> = <span class="ruby-identifier">parts</span>[<span class="ruby-value">1</span><span class="ruby-operator">..</span><span class="ruby-value">-1</span>].<span class="ruby-identifier">collect</span> {<span class="ruby-operator">|</span><span class="ruby-identifier">part</span><span class="ruby-operator">|</span> <span class="ruby-identifier">part</span>.<span class="ruby-identifier">join</span>(<span class="ruby-value str">&quot; &quot;</span>)}
1352: 
1353:             <span class="ruby-identifier">debug_msg</span> <span class="ruby-node">&quot;Wholenum: #{wholenum.inspect}; decimals: #{decimals.inspect}&quot;</span>
1354: 
1355:             <span class="ruby-comment cmt"># Join with the configured decimal; if it's empty, just join with</span>
1356:             <span class="ruby-comment cmt"># spaces.</span>
1357:             <span class="ruby-keyword kw">unless</span> <span class="ruby-identifier">config</span>[<span class="ruby-identifier">:decimal</span>].<span class="ruby-identifier">empty?</span>
1358:                 <span class="ruby-keyword kw">return</span> <span class="ruby-identifier">sign</span> <span class="ruby-operator">+</span> ([ <span class="ruby-identifier">wholenum</span> ] <span class="ruby-operator">+</span> <span class="ruby-identifier">decimals</span>).
1359:                     <span class="ruby-identifier">join</span>( <span class="ruby-node">&quot; #{config[:decimal]} &quot;</span> ).<span class="ruby-identifier">strip</span>
1360:             <span class="ruby-keyword kw">else</span>
1361:                 <span class="ruby-keyword kw">return</span> <span class="ruby-identifier">sign</span> <span class="ruby-operator">+</span> ([ <span class="ruby-identifier">wholenum</span> ] <span class="ruby-operator">+</span> <span class="ruby-identifier">decimals</span>).
1362:                     <span class="ruby-identifier">join</span>( <span class="ruby-value str">&quot; &quot;</span> ).<span class="ruby-identifier">strip</span>
1363:             <span class="ruby-keyword kw">end</span>
1364:         <span class="ruby-keyword kw">else</span>
1365:             <span class="ruby-keyword kw">return</span> <span class="ruby-identifier">parts</span>.<span class="ruby-identifier">compact</span>.
1366:                 <span class="ruby-identifier">separate</span>( <span class="ruby-identifier">config</span>[<span class="ruby-identifier">:decimal</span>] ).
1367:                 <span class="ruby-identifier">delete_if</span> {<span class="ruby-operator">|</span><span class="ruby-identifier">el</span><span class="ruby-operator">|</span> <span class="ruby-identifier">el</span>.<span class="ruby-identifier">empty?</span>}.
1368:                 <span class="ruby-identifier">join</span>( <span class="ruby-identifier">config</span>[<span class="ruby-identifier">:comma</span>] ).
1369:                 <span class="ruby-identifier">strip</span>
1370:         <span class="ruby-keyword kw">end</span>
1371:     <span class="ruby-keyword kw">end</span>
</pre>
          </div>
        </div>
      </div>

      <div id="method-M000053" class="method-detail">
        <a name="M000053"></a>

        <div class="method-heading">
          <a href="#M000053" class="method-signature">
          <span class="method-name">ordinal</span><span class="method-args">( number )</span>
          </a>
        </div>
      
        <div class="method-description">
          <p>
Transform the given <tt>number</tt> into <a href="EN.html#M000048">an</a>
<a href="EN.html#M000053">ordinal</a> word. The <tt>number</tt> object can
be either <a href="EN.html#M000048">an</a> Integer or <a
href="EN.html#M000047">a</a> String.
</p>
          <p><a class="source-toggle" href="#"
            onclick="toggleCode('M000053-source');return false;">[Source]</a></p>
          <div class="method-source-code" id="M000053-source">
<pre>
      <span class="ruby-comment cmt"># File lib/linguistics/en.rb, line 1377</span>
1377:     <span class="ruby-keyword kw">def</span> <span class="ruby-identifier">ordinal</span>( <span class="ruby-identifier">number</span> )
1378:         <span class="ruby-keyword kw">case</span> <span class="ruby-identifier">number</span>
1379:         <span class="ruby-keyword kw">when</span> <span class="ruby-constant">Integer</span>
1380:             <span class="ruby-keyword kw">return</span> <span class="ruby-identifier">number</span>.<span class="ruby-identifier">to_s</span> <span class="ruby-operator">+</span> (<span class="ruby-constant">Nth</span>[ <span class="ruby-identifier">number</span> <span class="ruby-operator">%</span> <span class="ruby-value">100</span> ] <span class="ruby-operator">||</span> <span class="ruby-constant">Nth</span>[ <span class="ruby-identifier">number</span> <span class="ruby-operator">%</span> <span class="ruby-value">10</span> ])
1381: 
1382:         <span class="ruby-keyword kw">else</span>
1383:             <span class="ruby-keyword kw">return</span> <span class="ruby-identifier">number</span>.<span class="ruby-identifier">to_s</span>.<span class="ruby-identifier">sub</span>( <span class="ruby-node">/(#{OrdinalSuffixes})\Z/</span> ) { <span class="ruby-constant">Ordinals</span>[<span class="ruby-identifier">$1</span>] }
1384:         <span class="ruby-keyword kw">end</span>
1385:     <span class="ruby-keyword kw">end</span>
</pre>
          </div>
        </div>
      </div>

      <div id="method-M000054" class="method-detail">
        <a name="M000054"></a>

        <div class="method-heading">
          <a href="#M000054" class="method-signature">
          <span class="method-name">ordinate</span><span class="method-args">( number )</span>
          </a>
        </div>
      
        <div class="method-description">
          <p>
Transform the given <tt>number</tt> into <a href="EN.html#M000048">an</a>
<a href="EN.html#M000054">ordinate</a> word.
</p>
          <p><a class="source-toggle" href="#"
            onclick="toggleCode('M000054-source');return false;">[Source]</a></p>
          <div class="method-source-code" id="M000054-source">
<pre>
      <span class="ruby-comment cmt"># File lib/linguistics/en.rb, line 1390</span>
1390:     <span class="ruby-keyword kw">def</span> <span class="ruby-identifier">ordinate</span>( <span class="ruby-identifier">number</span> )
1391:         <span class="ruby-identifier">numwords</span>( <span class="ruby-identifier">number</span> ).<span class="ruby-identifier">ordinal</span>
1392:     <span class="ruby-keyword kw">end</span>
</pre>
          </div>
        </div>
      </div>

      <div id="method-M000051" class="method-detail">
        <a name="M000051"></a>

        <div class="method-heading">
          <span class="method-name">part_pres</span><span class="method-args">( word )</span>
        </div>
      
        <div class="method-description">
          <p>
Alias for <a href="EN.html#M000050">#present_participle</a>
</p>
        </div>
      </div>

      <div id="method-M000042" class="method-detail">
        <a name="M000042"></a>

        <div class="method-heading">
          <a href="#M000042" class="method-signature">
          <span class="method-name">plural</span><span class="method-args">( phrase, count=nil )</span>
          </a>
        </div>
      
        <div class="method-description">
          <p>
Return the <a href="EN.html#M000042">plural</a> of the given
<tt>phrase</tt> if <tt>count</tt> indicates it should be <a
href="EN.html#M000042">plural</a>.
</p>
          <p><a class="source-toggle" href="#"
            onclick="toggleCode('M000042-source');return false;">[Source]</a></p>
          <div class="method-source-code" id="M000042-source">
<pre>
      <span class="ruby-comment cmt"># File lib/linguistics/en.rb, line 1128</span>
1128:     <span class="ruby-keyword kw">def</span> <span class="ruby-identifier">plural</span>( <span class="ruby-identifier">phrase</span>, <span class="ruby-identifier">count</span>=<span class="ruby-keyword kw">nil</span> )
1129:         <span class="ruby-identifier">phrase</span> = <span class="ruby-identifier">numwords</span>( <span class="ruby-identifier">phrase</span> ) <span class="ruby-keyword kw">if</span> <span class="ruby-identifier">phrase</span>.<span class="ruby-identifier">is_a?</span>( <span class="ruby-constant">Numeric</span> )
1130: 
1131:         <span class="ruby-identifier">md</span> = <span class="ruby-regexp re">/\A(\s*)(.+?)(\s*)\Z/</span>.<span class="ruby-identifier">match</span>( <span class="ruby-identifier">phrase</span>.<span class="ruby-identifier">to_s</span> )
1132:         <span class="ruby-identifier">pre</span>, <span class="ruby-identifier">word</span>, <span class="ruby-identifier">post</span> = <span class="ruby-identifier">md</span>.<span class="ruby-identifier">to_a</span>[<span class="ruby-value">1</span>,<span class="ruby-value">3</span>]
1133:         <span class="ruby-keyword kw">return</span> <span class="ruby-identifier">phrase</span> <span class="ruby-keyword kw">if</span> <span class="ruby-identifier">word</span>.<span class="ruby-identifier">nil?</span> <span class="ruby-keyword kw">or</span> <span class="ruby-identifier">word</span>.<span class="ruby-identifier">empty?</span>
1134: 
1135:         <span class="ruby-identifier">plural</span> = <span class="ruby-identifier">postprocess</span>( <span class="ruby-identifier">word</span>,
1136:             <span class="ruby-identifier">pluralize_special_adjective</span>(<span class="ruby-identifier">word</span>, <span class="ruby-identifier">count</span>) <span class="ruby-operator">||</span>
1137:             <span class="ruby-identifier">pluralize_special_verb</span>(<span class="ruby-identifier">word</span>, <span class="ruby-identifier">count</span>) <span class="ruby-operator">||</span>
1138:             <span class="ruby-identifier">pluralize_noun</span>(<span class="ruby-identifier">word</span>, <span class="ruby-identifier">count</span>) )
1139: 
1140:         <span class="ruby-keyword kw">return</span> <span class="ruby-identifier">pre</span> <span class="ruby-operator">+</span> <span class="ruby-identifier">plural</span> <span class="ruby-operator">+</span> <span class="ruby-identifier">post</span>
1141:     <span class="ruby-keyword kw">end</span>
</pre>
          </div>
        </div>
      </div>

      <div id="method-M000046" class="method-detail">
        <a name="M000046"></a>

        <div class="method-heading">
          <span class="method-name">plural_adj</span><span class="method-args">( phrase, count=nil )</span>
        </div>
      
        <div class="method-description">
          <p>
Alias for <a href="EN.html#M000045">#plural_adjective</a>
</p>
        </div>
      </div>

      <div id="method-M000045" class="method-detail">
        <a name="M000045"></a>

        <div class="method-heading">
          <a href="#M000045" class="method-signature">
          <span class="method-name">plural_adjective</span><span class="method-args">( phrase, count=nil )</span>
          </a>
        </div>
      
        <div class="method-description">
          <p>
Return the <a href="EN.html#M000042">plural</a> of the given adjectival
<tt>phrase</tt> if <tt>count</tt> indicates it should be <a
href="EN.html#M000042">plural</a>.
</p>
          <p><a class="source-toggle" href="#"
            onclick="toggleCode('M000045-source');return false;">[Source]</a></p>
          <div class="method-source-code" id="M000045-source">
<pre>
      <span class="ruby-comment cmt"># File lib/linguistics/en.rb, line 1175</span>
1175:     <span class="ruby-keyword kw">def</span> <span class="ruby-identifier">plural_adjective</span>( <span class="ruby-identifier">phrase</span>, <span class="ruby-identifier">count</span>=<span class="ruby-keyword kw">nil</span> )
1176:         <span class="ruby-identifier">md</span> = <span class="ruby-regexp re">/\A(\s*)(.+?)(\s*)\Z/</span>.<span class="ruby-identifier">match</span>( <span class="ruby-identifier">phrase</span>.<span class="ruby-identifier">to_s</span> )
1177:         <span class="ruby-identifier">pre</span>, <span class="ruby-identifier">word</span>, <span class="ruby-identifier">post</span> = <span class="ruby-identifier">md</span>.<span class="ruby-identifier">to_a</span>[<span class="ruby-value">1</span>,<span class="ruby-value">3</span>]
1178:         <span class="ruby-keyword kw">return</span> <span class="ruby-identifier">phrase</span> <span class="ruby-keyword kw">if</span> <span class="ruby-identifier">word</span>.<span class="ruby-identifier">nil?</span> <span class="ruby-keyword kw">or</span> <span class="ruby-identifier">word</span>.<span class="ruby-identifier">empty?</span>
1179: 
1180:         <span class="ruby-identifier">plural</span> = <span class="ruby-identifier">postprocess</span>( <span class="ruby-identifier">word</span>,
1181:             <span class="ruby-identifier">pluralize_special_adjective</span>(<span class="ruby-identifier">word</span>, <span class="ruby-identifier">count</span>) <span class="ruby-operator">||</span> <span class="ruby-identifier">word</span> )
1182:         <span class="ruby-keyword kw">return</span> <span class="ruby-identifier">pre</span> <span class="ruby-operator">+</span> <span class="ruby-identifier">plural</span> <span class="ruby-operator">+</span> <span class="ruby-identifier">post</span>
1183:     <span class="ruby-keyword kw">end</span>
</pre>
          </div>
        </div>
      </div>

      <div id="method-M000043" class="method-detail">
        <a name="M000043"></a>

        <div class="method-heading">
          <a href="#M000043" class="method-signature">
          <span class="method-name">plural_noun</span><span class="method-args">( phrase, count=nil )</span>
          </a>
        </div>
      
        <div class="method-description">
          <p>
Return the <a href="EN.html#M000042">plural</a> of the given noun
<tt>phrase</tt> if <tt>count</tt> indicates it should be <a
href="EN.html#M000042">plural</a>.
</p>
          <p><a class="source-toggle" href="#"
            onclick="toggleCode('M000043-source');return false;">[Source]</a></p>
          <div class="method-source-code" id="M000043-source">
<pre>
      <span class="ruby-comment cmt"># File lib/linguistics/en.rb, line 1147</span>
1147:     <span class="ruby-keyword kw">def</span> <span class="ruby-identifier">plural_noun</span>( <span class="ruby-identifier">phrase</span>, <span class="ruby-identifier">count</span>=<span class="ruby-keyword kw">nil</span> )
1148:         <span class="ruby-identifier">md</span> = <span class="ruby-regexp re">/\A(\s*)(.+?)(\s*)\Z/</span>.<span class="ruby-identifier">match</span>( <span class="ruby-identifier">phrase</span>.<span class="ruby-identifier">to_s</span> )
1149:         <span class="ruby-identifier">pre</span>, <span class="ruby-identifier">word</span>, <span class="ruby-identifier">post</span> = <span class="ruby-identifier">md</span>.<span class="ruby-identifier">to_a</span>[<span class="ruby-value">1</span>,<span class="ruby-value">3</span>]
1150:         <span class="ruby-keyword kw">return</span> <span class="ruby-identifier">phrase</span> <span class="ruby-keyword kw">if</span> <span class="ruby-identifier">word</span>.<span class="ruby-identifier">nil?</span> <span class="ruby-keyword kw">or</span> <span class="ruby-identifier">word</span>.<span class="ruby-identifier">empty?</span>
1151: 
1152:         <span class="ruby-identifier">plural</span> = <span class="ruby-identifier">postprocess</span>( <span class="ruby-identifier">word</span>, <span class="ruby-identifier">pluralize_noun</span>(<span class="ruby-identifier">word</span>, <span class="ruby-identifier">count</span>) )
1153:         <span class="ruby-keyword kw">return</span> <span class="ruby-identifier">pre</span> <span class="ruby-operator">+</span> <span class="ruby-identifier">plural</span> <span class="ruby-operator">+</span> <span class="ruby-identifier">post</span>
1154:     <span class="ruby-keyword kw">end</span>
</pre>
          </div>
        </div>
      </div>

      <div id="method-M000044" class="method-detail">
        <a name="M000044"></a>

        <div class="method-heading">
          <a href="#M000044" class="method-signature">
          <span class="method-name">plural_verb</span><span class="method-args">( phrase, count=nil )</span>
          </a>
        </div>
      
        <div class="method-description">
          <p>
Return the <a href="EN.html#M000042">plural</a> of the given verb
<tt>phrase</tt> if <tt>count</tt> indicates it should be <a
href="EN.html#M000042">plural</a>.
</p>
          <p><a class="source-toggle" href="#"
            onclick="toggleCode('M000044-source');return false;">[Source]</a></p>
          <div class="method-source-code" id="M000044-source">
<pre>
      <span class="ruby-comment cmt"># File lib/linguistics/en.rb, line 1160</span>
1160:     <span class="ruby-keyword kw">def</span> <span class="ruby-identifier">plural_verb</span>( <span class="ruby-identifier">phrase</span>, <span class="ruby-identifier">count</span>=<span class="ruby-keyword kw">nil</span> )
1161:         <span class="ruby-identifier">md</span> = <span class="ruby-regexp re">/\A(\s*)(.+?)(\s*)\Z/</span>.<span class="ruby-identifier">match</span>( <span class="ruby-identifier">phrase</span>.<span class="ruby-identifier">to_s</span> )
1162:         <span class="ruby-identifier">pre</span>, <span class="ruby-identifier">word</span>, <span class="ruby-identifier">post</span> = <span class="ruby-identifier">md</span>.<span class="ruby-identifier">to_a</span>[<span class="ruby-value">1</span>,<span class="ruby-value">3</span>]
1163:         <span class="ruby-keyword kw">return</span> <span class="ruby-identifier">phrase</span> <span class="ruby-keyword kw">if</span> <span class="ruby-identifier">word</span>.<span class="ruby-identifier">nil?</span> <span class="ruby-keyword kw">or</span> <span class="ruby-identifier">word</span>.<span class="ruby-identifier">empty?</span>
1164: 
1165:         <span class="ruby-identifier">plural</span> = <span class="ruby-identifier">postprocess</span>( <span class="ruby-identifier">word</span>,
1166:             <span class="ruby-identifier">pluralize_special_verb</span>(<span class="ruby-identifier">word</span>, <span class="ruby-identifier">count</span>) <span class="ruby-operator">||</span>
1167:             <span class="ruby-identifier">pluralize_general_verb</span>(<span class="ruby-identifier">word</span>, <span class="ruby-identifier">count</span>) )
1168:         <span class="ruby-keyword kw">return</span> <span class="ruby-identifier">pre</span> <span class="ruby-operator">+</span> <span class="ruby-identifier">plural</span> <span class="ruby-operator">+</span> <span class="ruby-identifier">post</span>
1169:     <span class="ruby-keyword kw">end</span>
</pre>
          </div>
        </div>
      </div>

      <div id="method-M000033" class="method-detail">
        <a name="M000033"></a>

        <div class="method-heading">
          <a href="#M000033" class="method-signature">
          <span class="method-name">pluralize_general_verb</span><span class="method-args">( word, count )</span>
          </a>
        </div>
      
        <div class="method-description">
          <p>
Pluralize regular verbs
</p>
          <p><a class="source-toggle" href="#"
            onclick="toggleCode('M000033-source');return false;">[Source]</a></p>
          <div class="method-source-code" id="M000033-source">
<pre>
     <span class="ruby-comment cmt"># File lib/linguistics/en.rb, line 900</span>
900:     <span class="ruby-keyword kw">def</span> <span class="ruby-identifier">pluralize_general_verb</span>( <span class="ruby-identifier">word</span>, <span class="ruby-identifier">count</span> )
901:         <span class="ruby-identifier">count</span> <span class="ruby-operator">||=</span> <span class="ruby-constant">Linguistics</span><span class="ruby-operator">::</span><span class="ruby-identifier">num</span>
902:         <span class="ruby-identifier">count</span> = <span class="ruby-identifier">normalize_count</span>( <span class="ruby-identifier">count</span> )
903:         
904:         <span class="ruby-keyword kw">return</span> <span class="ruby-identifier">word</span> <span class="ruby-keyword kw">if</span> <span class="ruby-node">/^(#{PL_count_one})$/i</span> <span class="ruby-operator">=~</span> <span class="ruby-identifier">count</span>.<span class="ruby-identifier">to_s</span>
905: 
906:         <span class="ruby-keyword kw">case</span> <span class="ruby-identifier">word</span>
907: 
908:         <span class="ruby-comment cmt"># Handle ambiguous present tenses  (simple and compound)</span>
909:         <span class="ruby-keyword kw">when</span> <span class="ruby-node">/^(#{PL_v_ambiguous_pres})((\s.*)?)$/i</span>
910:             <span class="ruby-keyword kw">return</span> <span class="ruby-constant">PL_v_ambiguous_pres_h</span>[ <span class="ruby-identifier">$1</span>.<span class="ruby-identifier">downcase</span> ] <span class="ruby-operator">+</span> <span class="ruby-identifier">$2</span>
911: 
912:         <span class="ruby-comment cmt"># Handle ambiguous preterite and perfect tenses</span>
913:         <span class="ruby-keyword kw">when</span> <span class="ruby-node">/^(#{PL_v_ambiguous_non_pres})((\s.*)?)$/i</span>
914:             <span class="ruby-keyword kw">return</span> <span class="ruby-identifier">word</span>
915: 
916:         <span class="ruby-comment cmt"># Otherwise, 1st or 2nd person is uninflected</span>
917:         <span class="ruby-keyword kw">else</span>
918:             <span class="ruby-keyword kw">return</span> <span class="ruby-identifier">word</span>
919:         <span class="ruby-keyword kw">end</span>
920:     <span class="ruby-keyword kw">end</span>
</pre>
          </div>
        </div>
      </div>

      <div id="method-M000031" class="method-detail">
        <a name="M000031"></a>

        <div class="method-heading">
          <a href="#M000031" class="method-signature">
          <span class="method-name">pluralize_noun</span><span class="method-args">( word, count=nil )</span>
          </a>
        </div>
      
        <div class="method-description">
          <p>
Pluralize nouns
</p>
          <p><a class="source-toggle" href="#"
            onclick="toggleCode('M000031-source');return false;">[Source]</a></p>
          <div class="method-source-code" id="M000031-source">
<pre>
     <span class="ruby-comment cmt"># File lib/linguistics/en.rb, line 727</span>
727:     <span class="ruby-keyword kw">def</span> <span class="ruby-identifier">pluralize_noun</span>( <span class="ruby-identifier">word</span>, <span class="ruby-identifier">count</span>=<span class="ruby-keyword kw">nil</span> )
728:         <span class="ruby-identifier">value</span> = <span class="ruby-keyword kw">nil</span>
729:         <span class="ruby-identifier">count</span> <span class="ruby-operator">||=</span> <span class="ruby-constant">Linguistics</span><span class="ruby-operator">::</span><span class="ruby-identifier">num</span>
730:         <span class="ruby-identifier">count</span> = <span class="ruby-identifier">normalize_count</span>( <span class="ruby-identifier">count</span> )
731: 
732:         <span class="ruby-keyword kw">return</span> <span class="ruby-identifier">word</span> <span class="ruby-keyword kw">if</span> <span class="ruby-identifier">count</span> <span class="ruby-operator">==</span> <span class="ruby-value">1</span>
733: 
734:         <span class="ruby-comment cmt"># Handle user-defined nouns</span>
735:         <span class="ruby-comment cmt">#if value = ud_match( word, PL_sb_user_defined )</span>
736:         <span class="ruby-comment cmt"># return value</span>
737:         <span class="ruby-comment cmt">#end</span>
738: 
739:         <span class="ruby-comment cmt"># Handle empty word, singular count and uninflected plurals</span>
740:         <span class="ruby-keyword kw">case</span> <span class="ruby-identifier">word</span>
741:         <span class="ruby-keyword kw">when</span> <span class="ruby-value str">''</span>
742:             <span class="ruby-keyword kw">return</span> <span class="ruby-identifier">word</span>
743:         <span class="ruby-keyword kw">when</span> <span class="ruby-node">/^(#{PL_sb_uninflected})$/i</span>
744:             <span class="ruby-keyword kw">return</span> <span class="ruby-identifier">word</span>
745:         <span class="ruby-keyword kw">else</span>
746:             <span class="ruby-keyword kw">if</span> <span class="ruby-constant">Linguistics</span><span class="ruby-operator">::</span><span class="ruby-identifier">classical?</span> <span class="ruby-operator">&amp;&amp;</span>
747:                <span class="ruby-node">/^(#{PL_sb_uninflected_herd})$/i</span> <span class="ruby-operator">=~</span> <span class="ruby-identifier">word</span>
748:                 <span class="ruby-keyword kw">return</span> <span class="ruby-identifier">word</span>
749:             <span class="ruby-keyword kw">end</span>
750:         <span class="ruby-keyword kw">end</span>
751: 
752:         <span class="ruby-comment cmt"># Handle compounds (&quot;Governor General&quot;, &quot;mother-in-law&quot;, &quot;aide-de-camp&quot;, etc.)</span>
753:         <span class="ruby-keyword kw">case</span> <span class="ruby-identifier">word</span>
754:         <span class="ruby-keyword kw">when</span> <span class="ruby-node">/^(?:#{PL_sb_postfix_adj})$/i</span>
755:             <span class="ruby-identifier">value</span> = <span class="ruby-identifier">$2</span>
756:             <span class="ruby-keyword kw">return</span> <span class="ruby-identifier">pluralize_noun</span>( <span class="ruby-identifier">$1</span>, <span class="ruby-value">2</span> ) <span class="ruby-operator">+</span> <span class="ruby-identifier">value</span>
757: 
758:         <span class="ruby-keyword kw">when</span> <span class="ruby-node">/^(?:#{PL_sb_prep_dual_compound})$/i</span>
759:             <span class="ruby-identifier">value</span> = [ <span class="ruby-identifier">$2</span>, <span class="ruby-identifier">$3</span> ] 
760:             <span class="ruby-keyword kw">return</span> <span class="ruby-identifier">pluralize_noun</span>( <span class="ruby-identifier">$1</span>, <span class="ruby-value">2</span> ) <span class="ruby-operator">+</span> <span class="ruby-identifier">value</span>[<span class="ruby-value">0</span>] <span class="ruby-operator">+</span> <span class="ruby-identifier">pluralize_noun</span>( <span class="ruby-identifier">value</span>[<span class="ruby-value">1</span>] )
761: 
762:         <span class="ruby-keyword kw">when</span> <span class="ruby-node">/^(?:#{PL_sb_prep_compound})$/i</span>
763:             <span class="ruby-identifier">value</span> = <span class="ruby-identifier">$2</span> 
764:             <span class="ruby-keyword kw">return</span> <span class="ruby-identifier">pluralize_noun</span>( <span class="ruby-identifier">$1</span>, <span class="ruby-value">2</span> ) <span class="ruby-operator">+</span> <span class="ruby-identifier">value</span>
765: 
766:         <span class="ruby-comment cmt"># Handle pronouns</span>
767:         <span class="ruby-keyword kw">when</span> <span class="ruby-node">/^((?:#{PL_prep})\s+)(#{PL_pron_acc})$/i</span>
768:             <span class="ruby-keyword kw">return</span> <span class="ruby-identifier">$1</span> <span class="ruby-operator">+</span> <span class="ruby-constant">PL_pron_acc_h</span>[ <span class="ruby-identifier">$2</span>.<span class="ruby-identifier">downcase</span> ]
769: 
770:         <span class="ruby-keyword kw">when</span> <span class="ruby-node">/^(#{PL_pron_nom})$/i</span>
771:             <span class="ruby-keyword kw">return</span> <span class="ruby-constant">PL_pron_nom_h</span>[ <span class="ruby-identifier">word</span>.<span class="ruby-identifier">downcase</span> ]
772: 
773:         <span class="ruby-keyword kw">when</span> <span class="ruby-node">/^(#{PL_pron_acc})$/i</span>
774:             <span class="ruby-keyword kw">return</span> <span class="ruby-constant">PL_pron_acc_h</span>[ <span class="ruby-identifier">$1</span>.<span class="ruby-identifier">downcase</span> ]
775: 
776:         <span class="ruby-comment cmt"># Handle isolated irregular plurals </span>
777:         <span class="ruby-keyword kw">when</span> <span class="ruby-node">/(.*)\b(#{PL_sb_irregular})$/i</span>
778:             <span class="ruby-keyword kw">return</span> <span class="ruby-identifier">$1</span> <span class="ruby-operator">+</span> <span class="ruby-constant">PL_sb_irregular_h</span>[ <span class="ruby-identifier">$2</span>.<span class="ruby-identifier">downcase</span> ]
779: 
780:         <span class="ruby-keyword kw">when</span> <span class="ruby-node">/(#{PL_sb_U_man_mans})$/i</span>
781:             <span class="ruby-keyword kw">return</span> <span class="ruby-node">&quot;#{$1}s&quot;</span>
782: 
783:         <span class="ruby-comment cmt"># Handle families of irregular plurals</span>
784:         <span class="ruby-keyword kw">when</span> <span class="ruby-regexp re">/(.*)man$/i</span> ;                    <span class="ruby-keyword kw">return</span> <span class="ruby-node">&quot;#{$1}men&quot;</span>
785:         <span class="ruby-keyword kw">when</span> <span class="ruby-regexp re">/(.*[ml])ouse$/i</span> ;               <span class="ruby-keyword kw">return</span> <span class="ruby-node">&quot;#{$1}ice&quot;</span>
786:         <span class="ruby-keyword kw">when</span> <span class="ruby-regexp re">/(.*)goose$/i</span> ;              <span class="ruby-keyword kw">return</span> <span class="ruby-node">&quot;#{$1}geese&quot;</span>
787:         <span class="ruby-keyword kw">when</span> <span class="ruby-regexp re">/(.*)tooth$/i</span> ;              <span class="ruby-keyword kw">return</span> <span class="ruby-node">&quot;#{$1}teeth&quot;</span>
788:         <span class="ruby-keyword kw">when</span> <span class="ruby-regexp re">/(.*)foot$/i</span> ;                   <span class="ruby-keyword kw">return</span> <span class="ruby-node">&quot;#{$1}feet&quot;</span>
789: 
790:         <span class="ruby-comment cmt"># Handle unassimilated imports</span>
791:         <span class="ruby-keyword kw">when</span> <span class="ruby-regexp re">/(.*)ceps$/i</span> ;                   <span class="ruby-keyword kw">return</span> <span class="ruby-identifier">word</span>
792:         <span class="ruby-keyword kw">when</span> <span class="ruby-regexp re">/(.*)zoon$/i</span> ;                   <span class="ruby-keyword kw">return</span> <span class="ruby-node">&quot;#{$1}zoa&quot;</span>
793:         <span class="ruby-keyword kw">when</span> <span class="ruby-regexp re">/(.*[csx])is$/i</span> ;                <span class="ruby-keyword kw">return</span> <span class="ruby-node">&quot;#{$1}es&quot;</span>
794:         <span class="ruby-keyword kw">when</span> <span class="ruby-node">/(#{PL_sb_U_ex_ices})ex$/i</span>;  <span class="ruby-keyword kw">return</span> <span class="ruby-node">&quot;#{$1}ices&quot;</span>
795:         <span class="ruby-keyword kw">when</span> <span class="ruby-node">/(#{PL_sb_U_ix_ices})ix$/i</span>;  <span class="ruby-keyword kw">return</span> <span class="ruby-node">&quot;#{$1}ices&quot;</span>
796:         <span class="ruby-keyword kw">when</span> <span class="ruby-node">/(#{PL_sb_U_um_a})um$/i</span> ;        <span class="ruby-keyword kw">return</span> <span class="ruby-node">&quot;#{$1}a&quot;</span>
797:         <span class="ruby-keyword kw">when</span> <span class="ruby-node">/(#{PL_sb_U_us_i})us$/i</span> ;        <span class="ruby-keyword kw">return</span> <span class="ruby-node">&quot;#{$1}i&quot;</span>
798:         <span class="ruby-keyword kw">when</span> <span class="ruby-node">/(#{PL_sb_U_on_a})on$/i</span> ;        <span class="ruby-keyword kw">return</span> <span class="ruby-node">&quot;#{$1}a&quot;</span>
799:         <span class="ruby-keyword kw">when</span> <span class="ruby-node">/(#{PL_sb_U_a_ae})$/i</span> ;      <span class="ruby-keyword kw">return</span> <span class="ruby-node">&quot;#{$1}e&quot;</span>
800:         <span class="ruby-keyword kw">end</span>
801: 
802:         <span class="ruby-comment cmt"># Handle incompletely assimilated imports</span>
803:         <span class="ruby-keyword kw">if</span> <span class="ruby-constant">Linguistics</span><span class="ruby-operator">::</span><span class="ruby-identifier">classical?</span>
804:             <span class="ruby-keyword kw">case</span> <span class="ruby-identifier">word</span>
805:             <span class="ruby-keyword kw">when</span> <span class="ruby-regexp re">/(.*)trix$/i</span> ;              <span class="ruby-keyword kw">return</span> <span class="ruby-node">&quot;#{$1}trices&quot;</span>
806:             <span class="ruby-keyword kw">when</span> <span class="ruby-regexp re">/(.*)eau$/i</span> ;               <span class="ruby-keyword kw">return</span> <span class="ruby-node">&quot;#{$1}eaux&quot;</span>
807:             <span class="ruby-keyword kw">when</span> <span class="ruby-regexp re">/(.*)ieu$/i</span> ;               <span class="ruby-keyword kw">return</span> <span class="ruby-node">&quot;#{$1}ieux&quot;</span>
808:             <span class="ruby-keyword kw">when</span> <span class="ruby-regexp re">/(.{2,}[yia])nx$/i</span> ;        <span class="ruby-keyword kw">return</span> <span class="ruby-node">&quot;#{$1}nges&quot;</span>
809:             <span class="ruby-keyword kw">when</span> <span class="ruby-node">/(#{PL_sb_C_en_ina})en$/i</span>; <span class="ruby-keyword kw">return</span> <span class="ruby-node">&quot;#{$1}ina&quot;</span>
810:             <span class="ruby-keyword kw">when</span> <span class="ruby-node">/(#{PL_sb_C_ex_ices})ex$/i</span>; <span class="ruby-keyword kw">return</span> <span class="ruby-node">&quot;#{$1}ices&quot;</span>
811:             <span class="ruby-keyword kw">when</span> <span class="ruby-node">/(#{PL_sb_C_ix_ices})ix$/i</span>; <span class="ruby-keyword kw">return</span> <span class="ruby-node">&quot;#{$1}ices&quot;</span>
812:             <span class="ruby-keyword kw">when</span> <span class="ruby-node">/(#{PL_sb_C_um_a})um$/i</span> ;   <span class="ruby-keyword kw">return</span> <span class="ruby-node">&quot;#{$1}a&quot;</span>
813:             <span class="ruby-keyword kw">when</span> <span class="ruby-node">/(#{PL_sb_C_us_i})us$/i</span> ;   <span class="ruby-keyword kw">return</span> <span class="ruby-node">&quot;#{$1}i&quot;</span>
814:             <span class="ruby-keyword kw">when</span> <span class="ruby-node">/(#{PL_sb_C_us_us})$/i</span> ;    <span class="ruby-keyword kw">return</span> <span class="ruby-node">&quot;#{$1}&quot;</span>
815:             <span class="ruby-keyword kw">when</span> <span class="ruby-node">/(#{PL_sb_C_a_ae})$/i</span> ; <span class="ruby-keyword kw">return</span> <span class="ruby-node">&quot;#{$1}e&quot;</span>
816:             <span class="ruby-keyword kw">when</span> <span class="ruby-node">/(#{PL_sb_C_a_ata})a$/i</span> ;   <span class="ruby-keyword kw">return</span> <span class="ruby-node">&quot;#{$1}ata&quot;</span>
817:             <span class="ruby-keyword kw">when</span> <span class="ruby-node">/(#{PL_sb_C_o_i})o$/i</span> ; <span class="ruby-keyword kw">return</span> <span class="ruby-node">&quot;#{$1}i&quot;</span>
818:             <span class="ruby-keyword kw">when</span> <span class="ruby-node">/(#{PL_sb_C_on_a})on$/i</span> ;   <span class="ruby-keyword kw">return</span> <span class="ruby-node">&quot;#{$1}a&quot;</span>
819:             <span class="ruby-keyword kw">when</span> <span class="ruby-node">/#{PL_sb_C_im}$/i</span> ;     <span class="ruby-keyword kw">return</span> <span class="ruby-node">&quot;#{word}im&quot;</span>
820:             <span class="ruby-keyword kw">when</span> <span class="ruby-node">/#{PL_sb_C_i}$/i</span> ;          <span class="ruby-keyword kw">return</span> <span class="ruby-node">&quot;#{word}i&quot;</span>
821:             <span class="ruby-keyword kw">end</span>
822:         <span class="ruby-keyword kw">end</span>
823: 
824: 
825:         <span class="ruby-comment cmt"># Handle singular nouns ending in ...s or other silibants</span>
826:         <span class="ruby-keyword kw">case</span> <span class="ruby-identifier">word</span>
827:         <span class="ruby-keyword kw">when</span> <span class="ruby-node">/^(#{PL_sb_singular_s})$/i</span>;  <span class="ruby-keyword kw">return</span> <span class="ruby-node">&quot;#{$1}es&quot;</span>
828:         <span class="ruby-keyword kw">when</span> <span class="ruby-regexp re">/^([A-Z].*s)$/</span>;              <span class="ruby-keyword kw">return</span> <span class="ruby-node">&quot;#{$1}es&quot;</span>
829:         <span class="ruby-keyword kw">when</span> <span class="ruby-regexp re">/(.*)([cs]h|[zx])$/i</span> ;           <span class="ruby-keyword kw">return</span> <span class="ruby-node">&quot;#{$1}#{$2}es&quot;</span>
830:         <span class="ruby-comment cmt"># when /(.*)(us)$/i ;             return &quot;#{$1}#{$2}es&quot;</span>
831: 
832:         <span class="ruby-comment cmt"># Handle ...f -&gt; ...ves</span>
833:         <span class="ruby-keyword kw">when</span> <span class="ruby-regexp re">/(.*[eao])lf$/i</span> ;                <span class="ruby-keyword kw">return</span> <span class="ruby-node">&quot;#{$1}lves&quot;</span>; 
834:         <span class="ruby-keyword kw">when</span> <span class="ruby-regexp re">/(.*[^d])eaf$/i</span> ;                <span class="ruby-keyword kw">return</span> <span class="ruby-node">&quot;#{$1}eaves&quot;</span>
835:         <span class="ruby-keyword kw">when</span> <span class="ruby-regexp re">/(.*[nlw])ife$/i</span> ;               <span class="ruby-keyword kw">return</span> <span class="ruby-node">&quot;#{$1}ives&quot;</span>
836:         <span class="ruby-keyword kw">when</span> <span class="ruby-regexp re">/(.*)arf$/i</span> ;                    <span class="ruby-keyword kw">return</span> <span class="ruby-node">&quot;#{$1}arves&quot;</span>
837: 
838:         <span class="ruby-comment cmt"># Handle ...y</span>
839:         <span class="ruby-keyword kw">when</span> <span class="ruby-regexp re">/(.*[aeiou])y$/i</span> ;               <span class="ruby-keyword kw">return</span> <span class="ruby-node">&quot;#{$1}ys&quot;</span>
840:         <span class="ruby-keyword kw">when</span> <span class="ruby-regexp re">/([A-Z].*y)$/</span> ;              <span class="ruby-keyword kw">return</span> <span class="ruby-node">&quot;#{$1}s&quot;</span>
841:         <span class="ruby-keyword kw">when</span> <span class="ruby-regexp re">/(.*)y$/i</span> ;                  <span class="ruby-keyword kw">return</span> <span class="ruby-node">&quot;#{$1}ies&quot;</span>
842: 
843:         <span class="ruby-comment cmt"># Handle ...o</span>
844:         <span class="ruby-keyword kw">when</span> <span class="ruby-node">/#{PL_sb_U_o_os}$/i</span> ;            <span class="ruby-keyword kw">return</span> <span class="ruby-node">&quot;#{word}s&quot;</span>
845:         <span class="ruby-keyword kw">when</span> <span class="ruby-regexp re">/[aeiou]o$/i</span> ;                   <span class="ruby-keyword kw">return</span> <span class="ruby-node">&quot;#{word}s&quot;</span>
846:         <span class="ruby-keyword kw">when</span> <span class="ruby-regexp re">/o$/i</span> ;                      <span class="ruby-keyword kw">return</span> <span class="ruby-node">&quot;#{word}es&quot;</span>
847: 
848:         <span class="ruby-comment cmt"># Otherwise just add ...s</span>
849:         <span class="ruby-keyword kw">else</span>
850:             <span class="ruby-keyword kw">return</span> <span class="ruby-node">&quot;#{word}s&quot;</span>
851:         <span class="ruby-keyword kw">end</span>
852:     <span class="ruby-keyword kw">end</span>
</pre>
          </div>
        </div>
      </div>

      <div id="method-M000034" class="method-detail">
        <a name="M000034"></a>

        <div class="method-heading">
          <a href="#M000034" class="method-signature">
          <span class="method-name">pluralize_special_adjective</span><span class="method-args">( word, count )</span>
          </a>
        </div>
      
        <div class="method-description">
          <p>
Handle special adjectives
</p>
          <p><a class="source-toggle" href="#"
            onclick="toggleCode('M000034-source');return false;">[Source]</a></p>
          <div class="method-source-code" id="M000034-source">
<pre>
     <span class="ruby-comment cmt"># File lib/linguistics/en.rb, line 924</span>
924:     <span class="ruby-keyword kw">def</span> <span class="ruby-identifier">pluralize_special_adjective</span>( <span class="ruby-identifier">word</span>, <span class="ruby-identifier">count</span> )
925:         <span class="ruby-identifier">count</span> <span class="ruby-operator">||=</span> <span class="ruby-constant">Linguistics</span><span class="ruby-operator">::</span><span class="ruby-identifier">num</span>
926:         <span class="ruby-identifier">count</span> = <span class="ruby-identifier">normalize_count</span>( <span class="ruby-identifier">count</span> )
927: 
928:         <span class="ruby-keyword kw">return</span> <span class="ruby-identifier">word</span> <span class="ruby-keyword kw">if</span> <span class="ruby-node">/^(#{PL_count_one})$/i</span> <span class="ruby-operator">=~</span> <span class="ruby-identifier">count</span>.<span class="ruby-identifier">to_s</span>
929: 
930:         <span class="ruby-comment cmt"># Handle user-defined verbs</span>
931:         <span class="ruby-comment cmt">#if value = ud_match( word, PL_adj_user_defined )</span>
932:         <span class="ruby-comment cmt"># return value</span>
933:         <span class="ruby-comment cmt">#end</span>
934: 
935:         <span class="ruby-keyword kw">case</span> <span class="ruby-identifier">word</span>
936: 
937:         <span class="ruby-comment cmt"># Handle known cases</span>
938:         <span class="ruby-keyword kw">when</span> <span class="ruby-node">/^(#{PL_adj_special})$/i</span>
939:             <span class="ruby-keyword kw">return</span> <span class="ruby-constant">PL_adj_special_h</span>[ <span class="ruby-identifier">$1</span>.<span class="ruby-identifier">downcase</span> ]
940: 
941:         <span class="ruby-comment cmt"># Handle possessives</span>
942:         <span class="ruby-keyword kw">when</span> <span class="ruby-node">/^(#{PL_adj_poss})$/i</span>
943:             <span class="ruby-keyword kw">return</span> <span class="ruby-constant">PL_adj_poss_h</span>[ <span class="ruby-identifier">$1</span>.<span class="ruby-identifier">downcase</span> ]
944: 
945:         <span class="ruby-keyword kw">when</span> <span class="ruby-regexp re">/^(.*)'s?$/</span>
946:             <span class="ruby-identifier">pl</span> = <span class="ruby-identifier">plural_noun</span>( <span class="ruby-identifier">$1</span> )
947:             <span class="ruby-keyword kw">if</span> <span class="ruby-regexp re">/s$/</span> <span class="ruby-operator">=~</span> <span class="ruby-identifier">pl</span>
948:                 <span class="ruby-keyword kw">return</span> <span class="ruby-node">&quot;#{pl}'&quot;</span>
949:             <span class="ruby-keyword kw">else</span>
950:                 <span class="ruby-keyword kw">return</span> <span class="ruby-node">&quot;#{pl}'s&quot;</span>
951:             <span class="ruby-keyword kw">end</span>
952: 
953:         <span class="ruby-comment cmt"># Otherwise, no idea</span>
954:         <span class="ruby-keyword kw">else</span>
955:             <span class="ruby-keyword kw">return</span> <span class="ruby-keyword kw">nil</span>
956:         <span class="ruby-keyword kw">end</span>
957:     <span class="ruby-keyword kw">end</span>
</pre>
          </div>
        </div>
      </div>

      <div id="method-M000032" class="method-detail">
        <a name="M000032"></a>

        <div class="method-heading">
          <a href="#M000032" class="method-signature">
          <span class="method-name">pluralize_special_verb</span><span class="method-args">( word, count )</span>
          </a>
        </div>
      
        <div class="method-description">
          <p>
Pluralize special verbs
</p>
          <p><a class="source-toggle" href="#"
            onclick="toggleCode('M000032-source');return false;">[Source]</a></p>
          <div class="method-source-code" id="M000032-source">
<pre>
     <span class="ruby-comment cmt"># File lib/linguistics/en.rb, line 857</span>
857:     <span class="ruby-keyword kw">def</span> <span class="ruby-identifier">pluralize_special_verb</span>( <span class="ruby-identifier">word</span>, <span class="ruby-identifier">count</span> )
858:         <span class="ruby-identifier">count</span> <span class="ruby-operator">||=</span> <span class="ruby-constant">Linguistics</span><span class="ruby-operator">::</span><span class="ruby-identifier">num</span>
859:         <span class="ruby-identifier">count</span> = <span class="ruby-identifier">normalize_count</span>( <span class="ruby-identifier">count</span> )
860:         
861:         <span class="ruby-keyword kw">return</span> <span class="ruby-keyword kw">nil</span> <span class="ruby-keyword kw">if</span> <span class="ruby-node">/^(#{PL_count_one})$/i</span> <span class="ruby-operator">=~</span> <span class="ruby-identifier">count</span>.<span class="ruby-identifier">to_s</span>
862: 
863:         <span class="ruby-comment cmt"># Handle user-defined verbs</span>
864:         <span class="ruby-comment cmt">#if value = ud_match( word, PL_v_user_defined )</span>
865:         <span class="ruby-comment cmt"># return value</span>
866:         <span class="ruby-comment cmt">#end</span>
867: 
868:         <span class="ruby-keyword kw">case</span> <span class="ruby-identifier">word</span>
869: 
870:         <span class="ruby-comment cmt"># Handle irregular present tense (simple and compound)</span>
871:         <span class="ruby-keyword kw">when</span> <span class="ruby-node">/^(#{PL_v_irregular_pres})((\s.*)?)$/i</span>
872:             <span class="ruby-keyword kw">return</span> <span class="ruby-constant">PL_v_irregular_pres_h</span>[ <span class="ruby-identifier">$1</span>.<span class="ruby-identifier">downcase</span> ] <span class="ruby-operator">+</span> <span class="ruby-identifier">$2</span>
873: 
874:         <span class="ruby-comment cmt"># Handle irregular future, preterite and perfect tenses </span>
875:         <span class="ruby-keyword kw">when</span> <span class="ruby-node">/^(#{PL_v_irregular_non_pres})((\s.*)?)$/i</span>
876:             <span class="ruby-keyword kw">return</span> <span class="ruby-identifier">word</span>
877: 
878:         <span class="ruby-comment cmt"># Handle special cases</span>
879:         <span class="ruby-keyword kw">when</span> <span class="ruby-node">/^(#{PL_v_special_s})$/</span>, <span class="ruby-regexp re">/\s/</span>
880:             <span class="ruby-keyword kw">return</span> <span class="ruby-keyword kw">nil</span>
881: 
882:         <span class="ruby-comment cmt"># Handle standard 3rd person (chop the ...(e)s off single words)</span>
883:         <span class="ruby-keyword kw">when</span> <span class="ruby-regexp re">/^(.*)([cs]h|[x]|zz|ss)es$/i</span>
884:             <span class="ruby-keyword kw">return</span> <span class="ruby-identifier">$1</span> <span class="ruby-operator">+</span> <span class="ruby-identifier">$2</span>
885:         <span class="ruby-keyword kw">when</span> <span class="ruby-regexp re">/^(..+)ies$/i</span>
886:             <span class="ruby-keyword kw">return</span> <span class="ruby-node">&quot;#{$1}y&quot;</span>
887:         <span class="ruby-keyword kw">when</span> <span class="ruby-regexp re">/^(.+)oes$/i</span>
888:             <span class="ruby-keyword kw">return</span> <span class="ruby-node">&quot;#{$1}o&quot;</span>
889:         <span class="ruby-keyword kw">when</span> <span class="ruby-regexp re">/^(.*[^s])s$/i</span>
890:             <span class="ruby-keyword kw">return</span> <span class="ruby-identifier">$1</span>
891: 
892:         <span class="ruby-comment cmt"># Otherwise, a regular verb (handle elsewhere)</span>
893:         <span class="ruby-keyword kw">else</span>
894:             <span class="ruby-keyword kw">return</span> <span class="ruby-keyword kw">nil</span>
895:         <span class="ruby-keyword kw">end</span>
896:     <span class="ruby-keyword kw">end</span>
</pre>
          </div>
        </div>
      </div>

      <div id="method-M000030" class="method-detail">
        <a name="M000030"></a>

        <div class="method-heading">
          <a href="#M000030" class="method-signature">
          <span class="method-name">postprocess</span><span class="method-args">( original, inflected )</span>
          </a>
        </div>
      
        <div class="method-description">
          <p>
Do normal/classical switching and match capitalization in
<tt>inflected</tt> by examining the <tt>original</tt> input.
</p>
          <p><a class="source-toggle" href="#"
            onclick="toggleCode('M000030-source');return false;">[Source]</a></p>
          <div class="method-source-code" id="M000030-source">
<pre>
     <span class="ruby-comment cmt"># File lib/linguistics/en.rb, line 705</span>
705:     <span class="ruby-keyword kw">def</span> <span class="ruby-identifier">postprocess</span>( <span class="ruby-identifier">original</span>, <span class="ruby-identifier">inflected</span> )
706:         <span class="ruby-identifier">inflected</span>.<span class="ruby-identifier">sub!</span>( <span class="ruby-regexp re">/([^|]+)\|(.+)/</span> ) {
707:             <span class="ruby-constant">Linguistics</span><span class="ruby-operator">::</span><span class="ruby-identifier">classical?</span> <span class="ruby-value">? </span><span class="ruby-identifier">$2</span> <span class="ruby-operator">:</span> <span class="ruby-identifier">$1</span>
708:         }
709: 
710:         <span class="ruby-keyword kw">case</span> <span class="ruby-identifier">original</span>
711:         <span class="ruby-keyword kw">when</span> <span class="ruby-value str">&quot;I&quot;</span>
712:             <span class="ruby-keyword kw">return</span> <span class="ruby-identifier">inflected</span>
713:         <span class="ruby-keyword kw">when</span> <span class="ruby-regexp re">/^[A-Z]+$/</span>
714:             <span class="ruby-keyword kw">return</span> <span class="ruby-identifier">inflected</span>.<span class="ruby-identifier">upcase</span>
715:         <span class="ruby-keyword kw">when</span> <span class="ruby-regexp re">/^[A-Z]/</span>
716:             <span class="ruby-comment cmt"># Can't use #capitalize, as it will downcase the rest of the string,</span>
717:             <span class="ruby-comment cmt"># too.</span>
718:             <span class="ruby-identifier">inflected</span>[<span class="ruby-value">0</span>,<span class="ruby-value">1</span>] = <span class="ruby-identifier">inflected</span>[<span class="ruby-value">0</span>,<span class="ruby-value">1</span>].<span class="ruby-identifier">upcase</span>
719:             <span class="ruby-keyword kw">return</span> <span class="ruby-identifier">inflected</span>
720:         <span class="ruby-keyword kw">else</span>
721:             <span class="ruby-keyword kw">return</span> <span class="ruby-identifier">inflected</span>
722:         <span class="ruby-keyword kw">end</span>
723:     <span class="ruby-keyword kw">end</span>
</pre>
          </div>
        </div>
      </div>

      <div id="method-M000050" class="method-detail">
        <a name="M000050"></a>

        <div class="method-heading">
          <a href="#M000050" class="method-signature">
          <span class="method-name">present_participle</span><span class="method-args">( word )</span>
          </a>
        </div>
      
        <div class="method-description">
          <p>
Participles
</p>
          <p><a class="source-toggle" href="#"
            onclick="toggleCode('M000050-source');return false;">[Source]</a></p>
          <div class="method-source-code" id="M000050-source">
<pre>
      <span class="ruby-comment cmt"># File lib/linguistics/en.rb, line 1219</span>
1219:     <span class="ruby-keyword kw">def</span> <span class="ruby-identifier">present_participle</span>( <span class="ruby-identifier">word</span> )
1220:         <span class="ruby-identifier">plural</span> = <span class="ruby-identifier">plural_verb</span>( <span class="ruby-identifier">word</span>.<span class="ruby-identifier">to_s</span>, <span class="ruby-value">2</span> )
1221:         
1222:         <span class="ruby-identifier">plural</span>.<span class="ruby-identifier">sub!</span>( <span class="ruby-regexp re">/ie$/</span>, <span class="ruby-value str">'y'</span> ) <span class="ruby-keyword kw">or</span>
1223:             <span class="ruby-identifier">plural</span>.<span class="ruby-identifier">sub!</span>( <span class="ruby-regexp re">/ue$/</span>, <span class="ruby-value str">'u'</span> ) <span class="ruby-keyword kw">or</span>
1224:             <span class="ruby-identifier">plural</span>.<span class="ruby-identifier">sub!</span>( <span class="ruby-regexp re">/([auy])e$/</span>, <span class="ruby-value str">'$1'</span> ) <span class="ruby-keyword kw">or</span>
1225:             <span class="ruby-identifier">plural</span>.<span class="ruby-identifier">sub!</span>( <span class="ruby-regexp re">/i$/</span>, <span class="ruby-value str">''</span> ) <span class="ruby-keyword kw">or</span>
1226:             <span class="ruby-identifier">plural</span>.<span class="ruby-identifier">sub!</span>( <span class="ruby-regexp re">/([^e])e$/</span>, <span class="ruby-value str">&quot;\\1&quot;</span> ) <span class="ruby-keyword kw">or</span>
1227:             <span class="ruby-regexp re">/er$/</span>.<span class="ruby-identifier">match</span>( <span class="ruby-identifier">plural</span> ) <span class="ruby-keyword kw">or</span>
1228:             <span class="ruby-identifier">plural</span>.<span class="ruby-identifier">sub!</span>( <span class="ruby-regexp re">/([^aeiou][aeiouy]([bdgmnprst]))$/</span>, <span class="ruby-value str">&quot;\\1\\2&quot;</span> )
1229: 
1230:         <span class="ruby-keyword kw">return</span> <span class="ruby-node">&quot;#{plural}ing&quot;</span>
1231:     <span class="ruby-keyword kw">end</span>
</pre>
          </div>
        </div>
      </div>

      <div id="method-M000059" class="method-detail">
        <a name="M000059"></a>

        <div class="method-heading">
          <a href="#M000059" class="method-signature">
          <span class="method-name">proper_noun</span><span class="method-args">( string )</span>
          </a>
        </div>
      
        <div class="method-description">
          <p>
Returns the proper noun form of <a href="EN.html#M000047">a</a> string by
capitalizing most of the words.
</p>
<p>
Examples:
</p>
<pre>
  English.proper_noun(&quot;bosnia and herzegovina&quot;) -&gt;
    &quot;Bosnia and Herzegovina&quot;
  English.proper_noun(&quot;macedonia, the former yugoslav republic of&quot;) -&gt;
    &quot;Macedonia, the Former Yugoslav Republic of&quot;
  English.proper_noun(&quot;virgin islands, u.s.&quot;) -&gt;
    &quot;Virgin Islands, U.S.&quot;
</pre>
          <p><a class="source-toggle" href="#"
            onclick="toggleCode('M000059-source');return false;">[Source]</a></p>
          <div class="method-source-code" id="M000059-source">
<pre>
      <span class="ruby-comment cmt"># File lib/linguistics/en.rb, line 1684</span>
1684:     <span class="ruby-keyword kw">def</span> <span class="ruby-identifier">proper_noun</span>( <span class="ruby-identifier">string</span> )
1685:         <span class="ruby-keyword kw">return</span> <span class="ruby-identifier">string</span>.<span class="ruby-identifier">split</span>(<span class="ruby-regexp re">/([ .]+)/</span>).<span class="ruby-identifier">collect</span> {<span class="ruby-operator">|</span><span class="ruby-identifier">word</span><span class="ruby-operator">|</span>
1686:             <span class="ruby-keyword kw">next</span> <span class="ruby-identifier">word</span> <span class="ruby-keyword kw">unless</span> <span class="ruby-regexp re">/^[a-z]/</span>.<span class="ruby-identifier">match</span>( <span class="ruby-identifier">word</span> ) <span class="ruby-operator">&amp;&amp;</span>
1687:                 <span class="ruby-operator">!</span> (<span class="ruby-node">%w{and the of}</span>.<span class="ruby-identifier">include?</span>( <span class="ruby-identifier">word</span> ))
1688:             <span class="ruby-identifier">word</span>.<span class="ruby-identifier">capitalize</span>
1689:         }.<span class="ruby-identifier">join</span>
1690:     <span class="ruby-keyword kw">end</span>
</pre>
          </div>
        </div>
      </div>

      <div id="method-M000055" class="method-detail">
        <a name="M000055"></a>

        <div class="method-heading">
          <a href="#M000055" class="method-signature">
          <span class="method-name">quantify</span><span class="method-args">( phrase, number=0, args={} )</span>
          </a>
        </div>
      
        <div class="method-description">
          <p>
Return <a href="EN.html#M000047">a</a> phrase describing the specified
<tt>number</tt> of objects in the given <tt>phrase</tt> in general terms.
The following options can be used to control the makeup of the returned
quantity String:
</p>
<dl>
<dt><b>:joinword</b></dt><dd>Sets the word (and any surrounding spaces) used as the word separating the
quantity from the noun in the resulting string. Defaults to <tt>&#8217; of
&#8216;</tt>.

</dd>
</dl>
          <p><a class="source-toggle" href="#"
            onclick="toggleCode('M000055-source');return false;">[Source]</a></p>
          <div class="method-source-code" id="M000055-source">
<pre>
      <span class="ruby-comment cmt"># File lib/linguistics/en.rb, line 1403</span>
1403:     <span class="ruby-keyword kw">def</span> <span class="ruby-identifier">quantify</span>( <span class="ruby-identifier">phrase</span>, <span class="ruby-identifier">number</span>=<span class="ruby-value">0</span>, <span class="ruby-identifier">args</span>={} )
1404:         <span class="ruby-identifier">num</span> = <span class="ruby-identifier">number</span>.<span class="ruby-identifier">to_i</span>
1405:         <span class="ruby-identifier">config</span> = <span class="ruby-constant">QuantifyDefaults</span>.<span class="ruby-identifier">merge</span>( <span class="ruby-identifier">args</span> )
1406:         
1407:         <span class="ruby-keyword kw">case</span> <span class="ruby-identifier">num</span>
1408:         <span class="ruby-keyword kw">when</span> <span class="ruby-value">0</span>
1409:             <span class="ruby-identifier">no</span>( <span class="ruby-identifier">phrase</span> )
1410:         <span class="ruby-keyword kw">when</span> <span class="ruby-value">1</span>
1411:             <span class="ruby-identifier">a</span>( <span class="ruby-identifier">phrase</span> )
1412:         <span class="ruby-keyword kw">when</span> <span class="ruby-constant">SeveralRange</span>
1413:             <span class="ruby-value str">&quot;several &quot;</span> <span class="ruby-operator">+</span> <span class="ruby-identifier">plural</span>( <span class="ruby-identifier">phrase</span>, <span class="ruby-identifier">num</span> )
1414:         <span class="ruby-keyword kw">when</span> <span class="ruby-constant">NumberRange</span>
1415:             <span class="ruby-value str">&quot;a number of &quot;</span> <span class="ruby-operator">+</span> <span class="ruby-identifier">plural</span>( <span class="ruby-identifier">phrase</span>, <span class="ruby-identifier">num</span> )
1416:         <span class="ruby-keyword kw">when</span> <span class="ruby-constant">NumerousRange</span>
1417:             <span class="ruby-value str">&quot;numerous &quot;</span> <span class="ruby-operator">+</span> <span class="ruby-identifier">plural</span>( <span class="ruby-identifier">phrase</span>, <span class="ruby-identifier">num</span> )
1418:         <span class="ruby-keyword kw">when</span> <span class="ruby-constant">ManyRange</span>
1419:             <span class="ruby-value str">&quot;many &quot;</span> <span class="ruby-operator">+</span> <span class="ruby-identifier">plural</span>( <span class="ruby-identifier">phrase</span>, <span class="ruby-identifier">num</span> )
1420:         <span class="ruby-keyword kw">else</span>
1421: 
1422:             <span class="ruby-comment cmt"># Anything bigger than the ManyRange gets described like</span>
1423:             <span class="ruby-comment cmt"># &quot;hundreds of thousands of...&quot; or &quot;millions of...&quot;</span>
1424:             <span class="ruby-comment cmt"># depending, of course, on how many there are.</span>
1425:             <span class="ruby-identifier">thousands</span>, <span class="ruby-identifier">subthousands</span> = <span class="ruby-constant">Math</span><span class="ruby-operator">::</span><span class="ruby-identifier">log10</span>( <span class="ruby-identifier">num</span> ).<span class="ruby-identifier">to_i</span>.<span class="ruby-identifier">divmod</span>( <span class="ruby-value">3</span> )
1426:             <span class="ruby-identifier">stword</span> =
1427:                 <span class="ruby-keyword kw">case</span> <span class="ruby-identifier">subthousands</span>
1428:                 <span class="ruby-keyword kw">when</span> <span class="ruby-value">2</span>
1429:                     <span class="ruby-value str">&quot;hundreds&quot;</span>
1430:                 <span class="ruby-keyword kw">when</span> <span class="ruby-value">1</span>
1431:                     <span class="ruby-value str">&quot;tens&quot;</span>
1432:                 <span class="ruby-keyword kw">else</span>
1433:                     <span class="ruby-keyword kw">nil</span>
1434:                 <span class="ruby-keyword kw">end</span>
1435:             <span class="ruby-identifier">thword</span> = <span class="ruby-identifier">plural</span>( <span class="ruby-identifier">to_thousands</span>(<span class="ruby-identifier">thousands</span>).<span class="ruby-identifier">strip</span> )
1436:             <span class="ruby-identifier">thword</span> = <span class="ruby-keyword kw">nil</span> <span class="ruby-keyword kw">if</span> <span class="ruby-identifier">thword</span>.<span class="ruby-identifier">empty?</span>
1437: 
1438:             [    <span class="ruby-comment cmt"># Hundreds (of)...</span>
1439:                 <span class="ruby-identifier">stword</span>,
1440: 
1441:                 <span class="ruby-comment cmt"># thousands (of)</span>
1442:                 <span class="ruby-identifier">thword</span>,
1443: 
1444:                 <span class="ruby-comment cmt"># stars.</span>
1445:                 <span class="ruby-identifier">plural</span>(<span class="ruby-identifier">phrase</span>, <span class="ruby-identifier">number</span>)
1446:             ].<span class="ruby-identifier">compact</span>.<span class="ruby-identifier">join</span>( <span class="ruby-identifier">config</span>[<span class="ruby-identifier">:joinword</span>] )
1447:         <span class="ruby-keyword kw">end</span>
1448:     <span class="ruby-keyword kw">end</span>
</pre>
          </div>
        </div>
      </div>

      <div id="method-M000019" class="method-detail">
        <a name="M000019"></a>

        <div class="method-heading">
          <a href="#M000019" class="method-signature">
          <span class="method-name">sentence</span><span class="method-args">( obj )</span>
          </a>
        </div>
      
        <div class="method-description">
          <p>
Return <a href="EN.html#M000047">a</a> LinkParser::Sentence for the
stringified <tt>obj</tt>.
</p>
          <p><a class="source-toggle" href="#"
            onclick="toggleCode('M000019-source');return false;">[Source]</a></p>
          <div class="method-source-code" id="M000019-source">
<pre>
     <span class="ruby-comment cmt"># File lib/linguistics/en/linkparser.rb, line 110</span>
110:     <span class="ruby-keyword kw">def</span> <span class="ruby-identifier">sentence</span>( <span class="ruby-identifier">obj</span> )
111:         <span class="ruby-keyword kw">return</span> <span class="ruby-constant">Linguistics</span><span class="ruby-operator">::</span><span class="ruby-constant">EN</span><span class="ruby-operator">::</span><span class="ruby-identifier">lp_dict</span>.<span class="ruby-identifier">parse</span>( <span class="ruby-identifier">obj</span>.<span class="ruby-identifier">to_s</span> )
112:     <span class="ruby-keyword kw">end</span>
</pre>
          </div>
        </div>
      </div>

      <div id="method-M000025" class="method-detail">
        <a name="M000025"></a>

        <div class="method-heading">
          <a href="#M000025" class="method-signature">
          <span class="method-name">synset</span><span class="method-args">( word, pos=nil, sense=1 )</span>
          </a>
        </div>
      
        <div class="method-description">
          <p>
Look up the <a href="EN.html#M000025">synset</a> associated with the given
word or collocation in the WordNet lexicon and return <a
href="EN.html#M000047">a</a> WordNet::Synset object.
</p>
          <p><a class="source-toggle" href="#"
            onclick="toggleCode('M000025-source');return false;">[Source]</a></p>
          <div class="method-source-code" id="M000025-source">
<pre>
     <span class="ruby-comment cmt"># File lib/linguistics/en/wordnet.rb, line 150</span>
150:     <span class="ruby-keyword kw">def</span> <span class="ruby-identifier">synset</span>( <span class="ruby-identifier">word</span>, <span class="ruby-identifier">pos</span>=<span class="ruby-keyword kw">nil</span>, <span class="ruby-identifier">sense</span>=<span class="ruby-value">1</span> )
151:         <span class="ruby-identifier">lex</span> = <span class="ruby-constant">Linguistics</span><span class="ruby-operator">::</span><span class="ruby-constant">EN</span><span class="ruby-operator">::</span><span class="ruby-identifier">wn_lexicon</span>
152:         <span class="ruby-keyword kw">if</span> <span class="ruby-identifier">pos</span>.<span class="ruby-identifier">is_a?</span>( <span class="ruby-constant">Fixnum</span> )
153:             <span class="ruby-identifier">sense</span> = <span class="ruby-identifier">pos</span>
154:             <span class="ruby-identifier">pos</span> = <span class="ruby-keyword kw">nil</span>
155:         <span class="ruby-keyword kw">end</span>
156:         <span class="ruby-identifier">postries</span> = <span class="ruby-identifier">pos</span> <span class="ruby-value">? </span>[<span class="ruby-identifier">pos</span>] <span class="ruby-operator">:</span> [<span class="ruby-identifier">:noun</span>, <span class="ruby-identifier">:verb</span>, <span class="ruby-identifier">:adjective</span>, <span class="ruby-identifier">:adverb</span>, <span class="ruby-identifier">:other</span>]
157:         <span class="ruby-identifier">syn</span> = <span class="ruby-keyword kw">nil</span>
158: 
159:         <span class="ruby-identifier">postries</span>.<span class="ruby-identifier">each</span> <span class="ruby-keyword kw">do</span> <span class="ruby-operator">|</span><span class="ruby-identifier">pos</span><span class="ruby-operator">|</span>
160:             <span class="ruby-keyword kw">break</span> <span class="ruby-keyword kw">if</span> <span class="ruby-identifier">syn</span> = <span class="ruby-identifier">lex</span>.<span class="ruby-identifier">lookup_synsets</span>( <span class="ruby-identifier">word</span>.<span class="ruby-identifier">to_s</span>, <span class="ruby-identifier">pos</span>, <span class="ruby-identifier">sense</span> )
161:         <span class="ruby-keyword kw">end</span>
162: 
163:         <span class="ruby-keyword kw">return</span> <span class="ruby-identifier">syn</span>
164:     <span class="ruby-keyword kw">end</span>
</pre>
          </div>
        </div>
      </div>

      <div id="method-M000026" class="method-detail">
        <a name="M000026"></a>

        <div class="method-heading">
          <a href="#M000026" class="method-signature">
          <span class="method-name">synsets</span><span class="method-args">( word, pos=nil )</span>
          </a>
        </div>
      
        <div class="method-description">
          <p>
Look up all the <a href="EN.html#M000026">synsets</a> associated with the
given word or collocation in the WordNet lexicon and return <a
href="EN.html#M000048">an</a> <a href="../Array.html">Array</a> of
WordNet::Synset objects. If <tt>pos</tt> is <tt>nil</tt>, return <a
href="EN.html#M000026">synsets</a> for all parts of speech.
</p>
          <p><a class="source-toggle" href="#"
            onclick="toggleCode('M000026-source');return false;">[Source]</a></p>
          <div class="method-source-code" id="M000026-source">
<pre>
     <span class="ruby-comment cmt"># File lib/linguistics/en/wordnet.rb, line 170</span>
170:     <span class="ruby-keyword kw">def</span> <span class="ruby-identifier">synsets</span>( <span class="ruby-identifier">word</span>, <span class="ruby-identifier">pos</span>=<span class="ruby-keyword kw">nil</span> )
171:         <span class="ruby-identifier">lex</span> = <span class="ruby-constant">Linguistics</span><span class="ruby-operator">::</span><span class="ruby-constant">EN</span><span class="ruby-operator">::</span><span class="ruby-identifier">wn_lexicon</span>
172:         <span class="ruby-identifier">postries</span> = <span class="ruby-identifier">pos</span> <span class="ruby-value">? </span>[<span class="ruby-identifier">pos</span>] <span class="ruby-operator">:</span> [<span class="ruby-identifier">:noun</span>, <span class="ruby-identifier">:verb</span>, <span class="ruby-identifier">:adjective</span>, <span class="ruby-identifier">:adverb</span>, <span class="ruby-identifier">:other</span>]
173:         <span class="ruby-identifier">syns</span> = []
174: 
175:         <span class="ruby-identifier">postries</span>.<span class="ruby-identifier">each</span> {<span class="ruby-operator">|</span><span class="ruby-identifier">pos</span><span class="ruby-operator">|</span>
176:             <span class="ruby-identifier">syns</span> <span class="ruby-operator">&lt;&lt;</span> <span class="ruby-identifier">lex</span>.<span class="ruby-identifier">lookup_synsets</span>( <span class="ruby-identifier">word</span>.<span class="ruby-identifier">to_s</span>, <span class="ruby-identifier">pos</span> )
177:         }
178: 
179:         <span class="ruby-keyword kw">return</span> <span class="ruby-identifier">syns</span>.<span class="ruby-identifier">flatten</span>.<span class="ruby-identifier">compact</span>
180:     <span class="ruby-keyword kw">end</span>
</pre>
          </div>
        </div>
      </div>

      <div id="method-M000038" class="method-detail">
        <a name="M000038"></a>

        <div class="method-heading">
          <a href="#M000038" class="method-signature">
          <span class="method-name">to_hundreds</span><span class="method-args">( hundreds, tens=0, units=0, thousands=0, joinword=&quot; and &quot; )</span>
          </a>
        </div>
      
        <div class="method-description">
          <p>
Transform the specified number of hundreds-, tens-, and units-place
numerals into <a href="EN.html#M000047">a</a> word phrase. If the number of
thousands (<tt>thousands</tt>) is greater than 0, it will be used to
determine where the decimal point is in relation to the hundreds-place
number.
</p>
          <p><a class="source-toggle" href="#"
            onclick="toggleCode('M000038-source');return false;">[Source]</a></p>
          <div class="method-source-code" id="M000038-source">
<pre>
      <span class="ruby-comment cmt"># File lib/linguistics/en.rb, line 1036</span>
1036:     <span class="ruby-keyword kw">def</span> <span class="ruby-identifier">to_hundreds</span>( <span class="ruby-identifier">hundreds</span>, <span class="ruby-identifier">tens</span>=<span class="ruby-value">0</span>, <span class="ruby-identifier">units</span>=<span class="ruby-value">0</span>, <span class="ruby-identifier">thousands</span>=<span class="ruby-value">0</span>, <span class="ruby-identifier">joinword</span>=<span class="ruby-value str">&quot; and &quot;</span> )
1037:         <span class="ruby-identifier">joinword</span> = <span class="ruby-value str">' '</span> <span class="ruby-keyword kw">if</span> <span class="ruby-identifier">joinword</span>.<span class="ruby-identifier">empty?</span>
1038:         <span class="ruby-keyword kw">if</span> <span class="ruby-identifier">hundreds</span>.<span class="ruby-identifier">nonzero?</span>
1039:             <span class="ruby-keyword kw">return</span> <span class="ruby-identifier">to_units</span>( <span class="ruby-identifier">hundreds</span> ) <span class="ruby-operator">+</span> <span class="ruby-value str">&quot; hundred&quot;</span> <span class="ruby-operator">+</span>
1040:                 (<span class="ruby-identifier">tens</span>.<span class="ruby-identifier">nonzero?</span> <span class="ruby-operator">||</span> <span class="ruby-identifier">units</span>.<span class="ruby-identifier">nonzero?</span> <span class="ruby-value">? </span><span class="ruby-identifier">joinword</span> <span class="ruby-operator">:</span> <span class="ruby-value str">''</span>) <span class="ruby-operator">+</span>
1041:                 <span class="ruby-identifier">to_tens</span>( <span class="ruby-identifier">tens</span>, <span class="ruby-identifier">units</span> ) <span class="ruby-operator">+</span>
1042:                 <span class="ruby-identifier">to_thousands</span>( <span class="ruby-identifier">thousands</span> )
1043:         <span class="ruby-keyword kw">elsif</span> <span class="ruby-identifier">tens</span>.<span class="ruby-identifier">nonzero?</span> <span class="ruby-operator">||</span> <span class="ruby-identifier">units</span>.<span class="ruby-identifier">nonzero?</span>
1044:             <span class="ruby-keyword kw">return</span> <span class="ruby-identifier">to_tens</span>( <span class="ruby-identifier">tens</span>, <span class="ruby-identifier">units</span> ) <span class="ruby-operator">+</span> <span class="ruby-identifier">to_thousands</span>( <span class="ruby-identifier">thousands</span> )
1045:         <span class="ruby-keyword kw">else</span>
1046:             <span class="ruby-keyword kw">return</span> <span class="ruby-keyword kw">nil</span>
1047:         <span class="ruby-keyword kw">end</span>
1048:     <span class="ruby-keyword kw">end</span>
</pre>
          </div>
        </div>
      </div>

      <div id="method-M000037" class="method-detail">
        <a name="M000037"></a>

        <div class="method-heading">
          <a href="#M000037" class="method-signature">
          <span class="method-name">to_tens</span><span class="method-args">( tens, units, thousands=0 )</span>
          </a>
        </div>
      
        <div class="method-description">
          <p>
Transform the specified number of tens- and units-place numerals into <a
href="EN.html#M000047">a</a> word-phrase at the given number of
<tt>thousands</tt> places.
</p>
          <p><a class="source-toggle" href="#"
            onclick="toggleCode('M000037-source');return false;">[Source]</a></p>
          <div class="method-source-code" id="M000037-source">
<pre>
      <span class="ruby-comment cmt"># File lib/linguistics/en.rb, line 1022</span>
1022:     <span class="ruby-keyword kw">def</span> <span class="ruby-identifier">to_tens</span>( <span class="ruby-identifier">tens</span>, <span class="ruby-identifier">units</span>, <span class="ruby-identifier">thousands</span>=<span class="ruby-value">0</span> )
1023:         <span class="ruby-keyword kw">unless</span> <span class="ruby-identifier">tens</span> <span class="ruby-operator">==</span> <span class="ruby-value">1</span>
1024:             <span class="ruby-keyword kw">return</span> <span class="ruby-constant">Tens</span>[ <span class="ruby-identifier">tens</span> ] <span class="ruby-operator">+</span> ( <span class="ruby-identifier">tens</span>.<span class="ruby-identifier">nonzero?</span> <span class="ruby-operator">&amp;&amp;</span> <span class="ruby-identifier">units</span>.<span class="ruby-identifier">nonzero?</span> <span class="ruby-value">? </span><span class="ruby-value str">'-'</span> <span class="ruby-operator">:</span> <span class="ruby-value str">''</span> ) <span class="ruby-operator">+</span>
1025:                 <span class="ruby-identifier">to_units</span>( <span class="ruby-identifier">units</span>, <span class="ruby-identifier">thousands</span> )
1026:         <span class="ruby-keyword kw">else</span>
1027:             <span class="ruby-keyword kw">return</span> <span class="ruby-constant">Teens</span>[ <span class="ruby-identifier">units</span> ] <span class="ruby-operator">+</span> <span class="ruby-identifier">to_thousands</span>( <span class="ruby-identifier">thousands</span> )
1028:         <span class="ruby-keyword kw">end</span>
1029:     <span class="ruby-keyword kw">end</span>
</pre>
          </div>
        </div>
      </div>

      <div id="method-M000039" class="method-detail">
        <a name="M000039"></a>

        <div class="method-heading">
          <a href="#M000039" class="method-signature">
          <span class="method-name">to_thousands</span><span class="method-args">( thousands=0 )</span>
          </a>
        </div>
      
        <div class="method-description">
          <p>
Transform the specified number into one or more words like
&#8216;thousand&#8217;, &#8216;million&#8217;, etc. Uses the thousands
(American) system.
</p>
          <p><a class="source-toggle" href="#"
            onclick="toggleCode('M000039-source');return false;">[Source]</a></p>
          <div class="method-source-code" id="M000039-source">
<pre>
      <span class="ruby-comment cmt"># File lib/linguistics/en.rb, line 1052</span>
1052:     <span class="ruby-keyword kw">def</span> <span class="ruby-identifier">to_thousands</span>( <span class="ruby-identifier">thousands</span>=<span class="ruby-value">0</span> )
1053:         <span class="ruby-identifier">parts</span> = []
1054:         (<span class="ruby-value">0</span><span class="ruby-operator">..</span><span class="ruby-identifier">thousands</span>).<span class="ruby-identifier">step</span>( <span class="ruby-constant">Thousands</span>.<span class="ruby-identifier">length</span> <span class="ruby-operator">-</span> <span class="ruby-value">1</span> ) {<span class="ruby-operator">|</span><span class="ruby-identifier">i</span><span class="ruby-operator">|</span>
1055:             <span class="ruby-keyword kw">if</span> <span class="ruby-identifier">i</span>.<span class="ruby-identifier">zero?</span>
1056:                 <span class="ruby-identifier">parts</span>.<span class="ruby-identifier">push</span> <span class="ruby-constant">Thousands</span>[ <span class="ruby-identifier">thousands</span> <span class="ruby-operator">%</span> (<span class="ruby-constant">Thousands</span>.<span class="ruby-identifier">length</span> <span class="ruby-operator">-</span> <span class="ruby-value">1</span>) ]
1057:             <span class="ruby-keyword kw">else</span>
1058:                 <span class="ruby-identifier">parts</span>.<span class="ruby-identifier">push</span> <span class="ruby-constant">Thousands</span>.<span class="ruby-identifier">last</span>
1059:             <span class="ruby-keyword kw">end</span>
1060:         }
1061: 
1062:         <span class="ruby-keyword kw">return</span> <span class="ruby-identifier">parts</span>.<span class="ruby-identifier">join</span>(<span class="ruby-value str">&quot; &quot;</span>)
1063:     <span class="ruby-keyword kw">end</span>
</pre>
          </div>
        </div>
      </div>

      <div id="method-M000036" class="method-detail">
        <a name="M000036"></a>

        <div class="method-heading">
          <a href="#M000036" class="method-signature">
          <span class="method-name">to_units</span><span class="method-args">( units, thousands=0 )</span>
          </a>
        </div>
      
        <div class="method-description">
          <p>
Transform the specified number of units-place numerals into <a
href="EN.html#M000047">a</a> word-phrase at the given number of
<tt>thousands</tt> places.
</p>
          <p><a class="source-toggle" href="#"
            onclick="toggleCode('M000036-source');return false;">[Source]</a></p>
          <div class="method-source-code" id="M000036-source">
<pre>
      <span class="ruby-comment cmt"># File lib/linguistics/en.rb, line 1015</span>
1015:     <span class="ruby-keyword kw">def</span> <span class="ruby-identifier">to_units</span>( <span class="ruby-identifier">units</span>, <span class="ruby-identifier">thousands</span>=<span class="ruby-value">0</span> )
1016:         <span class="ruby-keyword kw">return</span> <span class="ruby-constant">Units</span>[ <span class="ruby-identifier">units</span> ] <span class="ruby-operator">+</span> <span class="ruby-identifier">to_thousands</span>( <span class="ruby-identifier">thousands</span> )
1017:     <span class="ruby-keyword kw">end</span>
</pre>
          </div>
        </div>
      </div>


    </div>


  </div>


<div id="validator-badges">
  <p><small><a href="http://validator.w3.org/check/referer">[Validate]</a></small></p>
</div>

</body>
</html>